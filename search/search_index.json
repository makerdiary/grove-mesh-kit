{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Grove Mesh Kit for nRF52840-MDK Build Mesh network with nRF52840-MDK and Grove Description Grove Mesh Kit for nRF52840-MDK is a very versatile mesh networking development kit. It integrates nRF52840-MDK development board, Base Dock and SeeedStudio 's most popular and easy-to-use Grove Modules . Grove Mesh Kit takes a full advantage of the multiprotocol capabilities of the nRF52840 SoC by supporting Bluetooth Mesh and OpenThread Mesh networking. It allows developers to create IoT applications with Mesh Network Connectivity in a very short time. Features The key features of the Grove Mesh Kit are: nRF52840 Micro Development Kit(nRF52840-MDK) nRF52840 Advanced Bluetooth 5, Thread and Zigbee multiprotocol SoC Program/Debug options with DAPLink Microchip 2-Port USB 2.0 Hi-Speed Hub Controller External ultra-low power 64-Mb QSPI FLASH memory On-board 2.4G chip antenna U.FL connector selectable for external antenna Reversible USB 3.1 Type-C Connector Buttons and LEDs for user interaction Up to 24 GPIOs available via headers Base Dock (Grove Compatible) Dual 2x18 Socket Headers 4 Grove connectors with UART/I2C/I2S/PDM/QDEC/SPI/ADC selectable Supporting NFC-A Listen Mode with PCB NFC Antenna AA Battery power supply Power Button with Latching Circuit Battery level sensing 6 easy-to-use Grove modules Grove - Button Grove - Light Sensor Grove - Rotary Angle Sensor Grove - Sound Sensor Grove - Temperature Sensor Grove - Touch Sensor Block Diagram Included in the Box nRF52840 Micro Development Kit Base Dock (Grove Compatible) Grove Modules Grove - Button Grove - Light Sensor Grove - Rotary Angle Sensor Grove - Sound Sensor Grove - Temperature Sensor Grove - Touch Sensor Tutorials We think the best way to learn is by doing. And to help you get started, we have provided a series of tutorials. Find the details below. Getting Started with Grove Mesh Kit Grove Mesh Kit with nRF5 SDK Bluetooth Mesh Networking OpenThread Mesh Networking Create an Issue Interested in contributing to this project? Want to report a bug? Feel free to click here: Create an Issue","title":"Introduction"},{"location":"#grove-mesh-kit-for-nrf52840-mdk-build-mesh-network-with-nrf52840-mdk-and-grove","text":"","title":"Grove Mesh Kit for nRF52840-MDK Build Mesh network with nRF52840-MDK and Grove"},{"location":"#description","text":"Grove Mesh Kit for nRF52840-MDK is a very versatile mesh networking development kit. It integrates nRF52840-MDK development board, Base Dock and SeeedStudio 's most popular and easy-to-use Grove Modules . Grove Mesh Kit takes a full advantage of the multiprotocol capabilities of the nRF52840 SoC by supporting Bluetooth Mesh and OpenThread Mesh networking. It allows developers to create IoT applications with Mesh Network Connectivity in a very short time.","title":"Description"},{"location":"#features","text":"The key features of the Grove Mesh Kit are: nRF52840 Micro Development Kit(nRF52840-MDK) nRF52840 Advanced Bluetooth 5, Thread and Zigbee multiprotocol SoC Program/Debug options with DAPLink Microchip 2-Port USB 2.0 Hi-Speed Hub Controller External ultra-low power 64-Mb QSPI FLASH memory On-board 2.4G chip antenna U.FL connector selectable for external antenna Reversible USB 3.1 Type-C Connector Buttons and LEDs for user interaction Up to 24 GPIOs available via headers Base Dock (Grove Compatible) Dual 2x18 Socket Headers 4 Grove connectors with UART/I2C/I2S/PDM/QDEC/SPI/ADC selectable Supporting NFC-A Listen Mode with PCB NFC Antenna AA Battery power supply Power Button with Latching Circuit Battery level sensing 6 easy-to-use Grove modules Grove - Button Grove - Light Sensor Grove - Rotary Angle Sensor Grove - Sound Sensor Grove - Temperature Sensor Grove - Touch Sensor","title":"Features"},{"location":"#block-diagram","text":"","title":"Block Diagram"},{"location":"#included-in-the-box","text":"nRF52840 Micro Development Kit Base Dock (Grove Compatible) Grove Modules Grove - Button Grove - Light Sensor Grove - Rotary Angle Sensor Grove - Sound Sensor Grove - Temperature Sensor Grove - Touch Sensor","title":"Included in the Box"},{"location":"#tutorials","text":"We think the best way to learn is by doing. And to help you get started, we have provided a series of tutorials. Find the details below. Getting Started with Grove Mesh Kit Grove Mesh Kit with nRF5 SDK Bluetooth Mesh Networking OpenThread Mesh Networking","title":"Tutorials"},{"location":"#create-an-issue","text":"Interested in contributing to this project? Want to report a bug? Feel free to click here: Create an Issue","title":"Create an Issue"},{"location":"CONTRIBUTING/","text":"Contributing Interested in contributing to this project? Want to report a bug? Before you do, please read the following guidelines. Got a question or problem? For quick questions there's no need to open an issue as you can reach us on makerdiary/community . Found a bug? If you found a bug in the source code, you can help us by submitting an issue to the issue tracker in our GitHub repository. Even better, you can submit a Pull Request with a fix. Requesting a tutorial If you don't see what you're looking for, you can request a tutoial by submitting an issue to our GitHub Repository. We'd love to see your feedback! Request a tutoial","title":"Contributing"},{"location":"CONTRIBUTING/#contributing","text":"Interested in contributing to this project? Want to report a bug? Before you do, please read the following guidelines.","title":"Contributing"},{"location":"CONTRIBUTING/#got-a-question-or-problem","text":"For quick questions there's no need to open an issue as you can reach us on makerdiary/community .","title":"Got a question or problem?"},{"location":"CONTRIBUTING/#found-a-bug","text":"If you found a bug in the source code, you can help us by submitting an issue to the issue tracker in our GitHub repository. Even better, you can submit a Pull Request with a fix.","title":"Found a bug?"},{"location":"CONTRIBUTING/#requesting-a-tutorial","text":"If you don't see what you're looking for, you can request a tutoial by submitting an issue to our GitHub Repository. We'd love to see your feedback! Request a tutoial","title":"Requesting a tutorial"},{"location":"getting-started/","text":"Getting started with the Grove Mesh Kit This guide describes how to start working with the Grove Mesh Kit in just a few minutes. Included in the Box Your Grove Mesh Kit box includes the following parts: nRF52840 Micro Development Kit Base Dock (Grove Compatible) Grove - Button Grove - Light Sensor Grove Rotary Angle Sensor Grove - Sound Sensor Grove - Temperature Sensor Grove - Touch Sensor USB 3.1 Type-C Cable M3 Screws Plastic Spacers Assemble the hardware Place the nRF52840-MDK board onto the Base Dock Connect the Grove modules to the Base Dock Attach the four plastic spacers supplied in your box to act as legs for the Base Dock Insert an AA battery into the holder the right way around as marked on the board Tip AA battery is NOT included in the kit. The Energizer\u00ae Ultimate Lithium\u2122 AA battery is recommended to stay powered longer. Clone the repository Clone the grove-mesh-kit repository from GitHub: git clone --recursive https://github.com/makerdiary/grove-mesh-kit This repository provides documents and examples that you can run on your kit to ensure that everything is set up correctly. Run the Grove CLI example To quickly explore the modules, run the Grove CLI example provided with the Grove Mesh Kit. Grove CLI is a minimal application that exposes the Grove configuration and management interfaces via a basic command-line interface. This example source code is located in examples/grove_cli . Flash the nRF52840-MDK Follow these steps to flash the Grove CLI pre-built firmware. Connect the nRF52840-MDK board to your PC using the USB-C cable. Open a file explorer. Confirm that the board has appeared as a removable drive named DAPLINK . This allows you to program the nRF52840 chip. Drag and drop the pre-built firmware into DAPLINK . The Grove CLI pre-built firmware is located in grove-mesh-kit/examples/grove_cli/hex . Tip You can also program the board using pyOCD . Just follow this tutorial to set up the pyOCD tool. Explore the Grove modules You can explore the Grove modules using a serial terminal like screen or PuTTY . In Terminal, run: screen /dev/cu.usbmodem846fa1a9d0de1 115200 If you are using Windows OS, run the PuTTY application instead: Tip Replace the serial port name /dev/cu.usbmodem846fa1a9d0de1 or COM16 with yours. For your convenience, our Web Device CLI provides a Web Command Line Interface using Web Bluetooth. Here, we use the Web Device CLI to demonstrate the Grove CLI example. The commands should work similarly in your serial terminal. Upon powering up the board with the USB or AA battery, the GREEN LED starts blinking. The device is advertising as Grove CLI . Start the Web Device CLI by clicking the following link: Start Web Device CLI Click the Connect button and pair the Grove CLI device. Type grove and press the Enter button to see the hints. Read the Grove - Rotary Angle Sensor connected to PORT#2 by running: grove angle -p 2 You will see the result like this: grove_cli:~$ grove angle -p 2 ADC RAW: 629 Angle: 201 [ degree ] grove_cli:~$ Read the Grove - Light Sensor connected to PORT#3 by running: grove light -p 3 The CLI outputs like this: grove_cli:~$ grove light -p 3 ADC RAW: 27 Voltage: 94 [ mV ] grove_cli:~$ Read the Grove - Sound Sensor connected to PORT#4 by running: grove sound -p 4 You will get the sound level: grove_cli:~$ grove sound -p 4 Sound Level: 47 [ dB ] grove_cli:~$ Read the Grove - Temperature Sensor connected to PORT#2 by running: grove temp -p 2 You can get the ambient temperature: grove_cli:~$ grove temp -p 2 ADC RAW: 493 Temperature: 23 .50 [ degreeC ] grove_cli:~$ Connnect the Grove - Button to PORT#1, then run: grove button enable -p 1 Press and release the button. The CLI outputs like this: grove_cli:~$ grove button enable -p 1 Grove Button on Port1 Enabled grove_cli:~$ Button on Port1: Pressed Button on Port1: Released Connect the Grove - Touch Sensor to PORT#2, and run: grove touch enable -p 2 Touch and release the touch pad. The CLI outputs like this: grove_cli:~$ grove touch enable -p 2 Grove Touch on Port2 Enabled grove_cli:~$ Touch on Port2: Touched Touch on Port2: Released Next Steps Congratulations! You may find your way around: Head to the nRF5 SDK Tutorial Page for building an nRF5 SDK example like Grove CLI Check out the Mesh networking tutorials including: Bluetooth Mesh Network OpenThread Mesh Network Many more details about the kit hardware can be found here: nRF52840-MDK Documentation Base Dock Documentation Grove Wiki Create an Issue Interested in contributing to this project? Want to report a bug? Feel free to click here: Create an Issue","title":"Getting Started"},{"location":"getting-started/#getting-started-with-the-grove-mesh-kit","text":"This guide describes how to start working with the Grove Mesh Kit in just a few minutes.","title":"Getting started with the Grove Mesh Kit"},{"location":"getting-started/#included-in-the-box","text":"Your Grove Mesh Kit box includes the following parts: nRF52840 Micro Development Kit Base Dock (Grove Compatible) Grove - Button Grove - Light Sensor Grove Rotary Angle Sensor Grove - Sound Sensor Grove - Temperature Sensor Grove - Touch Sensor USB 3.1 Type-C Cable M3 Screws Plastic Spacers","title":"Included in the Box"},{"location":"getting-started/#assemble-the-hardware","text":"Place the nRF52840-MDK board onto the Base Dock Connect the Grove modules to the Base Dock Attach the four plastic spacers supplied in your box to act as legs for the Base Dock Insert an AA battery into the holder the right way around as marked on the board Tip AA battery is NOT included in the kit. The Energizer\u00ae Ultimate Lithium\u2122 AA battery is recommended to stay powered longer.","title":"Assemble the hardware"},{"location":"getting-started/#clone-the-repository","text":"Clone the grove-mesh-kit repository from GitHub: git clone --recursive https://github.com/makerdiary/grove-mesh-kit This repository provides documents and examples that you can run on your kit to ensure that everything is set up correctly.","title":"Clone the repository"},{"location":"getting-started/#run-the-grove-cli-example","text":"To quickly explore the modules, run the Grove CLI example provided with the Grove Mesh Kit. Grove CLI is a minimal application that exposes the Grove configuration and management interfaces via a basic command-line interface. This example source code is located in examples/grove_cli .","title":"Run the Grove CLI example"},{"location":"getting-started/#flash-the-nrf52840-mdk","text":"Follow these steps to flash the Grove CLI pre-built firmware. Connect the nRF52840-MDK board to your PC using the USB-C cable. Open a file explorer. Confirm that the board has appeared as a removable drive named DAPLINK . This allows you to program the nRF52840 chip. Drag and drop the pre-built firmware into DAPLINK . The Grove CLI pre-built firmware is located in grove-mesh-kit/examples/grove_cli/hex . Tip You can also program the board using pyOCD . Just follow this tutorial to set up the pyOCD tool.","title":"Flash the nRF52840-MDK"},{"location":"getting-started/#explore-the-grove-modules","text":"You can explore the Grove modules using a serial terminal like screen or PuTTY . In Terminal, run: screen /dev/cu.usbmodem846fa1a9d0de1 115200 If you are using Windows OS, run the PuTTY application instead: Tip Replace the serial port name /dev/cu.usbmodem846fa1a9d0de1 or COM16 with yours. For your convenience, our Web Device CLI provides a Web Command Line Interface using Web Bluetooth. Here, we use the Web Device CLI to demonstrate the Grove CLI example. The commands should work similarly in your serial terminal. Upon powering up the board with the USB or AA battery, the GREEN LED starts blinking. The device is advertising as Grove CLI . Start the Web Device CLI by clicking the following link: Start Web Device CLI Click the Connect button and pair the Grove CLI device. Type grove and press the Enter button to see the hints. Read the Grove - Rotary Angle Sensor connected to PORT#2 by running: grove angle -p 2 You will see the result like this: grove_cli:~$ grove angle -p 2 ADC RAW: 629 Angle: 201 [ degree ] grove_cli:~$ Read the Grove - Light Sensor connected to PORT#3 by running: grove light -p 3 The CLI outputs like this: grove_cli:~$ grove light -p 3 ADC RAW: 27 Voltage: 94 [ mV ] grove_cli:~$ Read the Grove - Sound Sensor connected to PORT#4 by running: grove sound -p 4 You will get the sound level: grove_cli:~$ grove sound -p 4 Sound Level: 47 [ dB ] grove_cli:~$ Read the Grove - Temperature Sensor connected to PORT#2 by running: grove temp -p 2 You can get the ambient temperature: grove_cli:~$ grove temp -p 2 ADC RAW: 493 Temperature: 23 .50 [ degreeC ] grove_cli:~$ Connnect the Grove - Button to PORT#1, then run: grove button enable -p 1 Press and release the button. The CLI outputs like this: grove_cli:~$ grove button enable -p 1 Grove Button on Port1 Enabled grove_cli:~$ Button on Port1: Pressed Button on Port1: Released Connect the Grove - Touch Sensor to PORT#2, and run: grove touch enable -p 2 Touch and release the touch pad. The CLI outputs like this: grove_cli:~$ grove touch enable -p 2 Grove Touch on Port2 Enabled grove_cli:~$ Touch on Port2: Touched Touch on Port2: Released","title":"Explore the Grove modules"},{"location":"getting-started/#next-steps","text":"Congratulations! You may find your way around: Head to the nRF5 SDK Tutorial Page for building an nRF5 SDK example like Grove CLI Check out the Mesh networking tutorials including: Bluetooth Mesh Network OpenThread Mesh Network Many more details about the kit hardware can be found here: nRF52840-MDK Documentation Base Dock Documentation Grove Wiki","title":"Next Steps"},{"location":"getting-started/#create-an-issue","text":"Interested in contributing to this project? Want to report a bug? Feel free to click here: Create an Issue","title":"Create an Issue"},{"location":"license/","text":"MIT License Copyright 2019 makerdiary Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"license/#mit-license","text":"Copyright 2019 makerdiary Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"MIT License"},{"location":"setting-up-nrf5-sdk/","text":"nRF5 SDK Offical Software Development Kit for nRF51 and nRF52 Series Overview The nRF5 SDK is your first stop for building fully featured, reliable and secure applications with the nRF52 and nRF51 Series. It offers developers a wealth of varied modules and examples right across the spectrum including numerous Bluetooth Low Energy profiles, Device Firmware Upgrade (DFU), GATT serializer and driver support for all peripherals on all nRF5 Series devices. The nRF5 SDK will almost certainly have something for your needs in developing exciting yet robust wireless products. Follow this guide to set up a nRF5 SDK development environment on your system, and then build and run a sample application. Set up the toolchain To build the nRF5 SDK examples, GNU ARM Embedded Toolchain is required. Follow one of the following guides for your host operating system: macOS Windows Linux macOS GNU make is bundled with Xcode tools. Verify by running: make --v Download and install the GNU ARM Embedded Toolchain . The 6-2017-q2-update version is recommended. Then ensure the path is added to your OS PATH environment variable. # in ~/.bash_profile, add the following script export PATH = path to install directory /gcc-arm-none-eabi-6-2017-q2-update/bin: ${ PATH } Type the following in your terminal to verify if the path is set correctly: arm-none-eabi-gcc --version Download the nRF5x-Command-Line-Tools-OSX , then extract the .tar archive anywhere on your filesystem. Ensure the extracted directory is added to your OS PATH environment variable. # in ~/.bash_profile, add the following script export PATH = the path to the extracted directory : ${ PATH } Type the following in your terminal to verify if mergehex works: mergehex --version Install the latest stable version of pyOCD via pip as follows: pip install -U pyocd Type the following in your terminal to verify if pyocd works: pyocd --version Windows On Windows the easiest way to install the dependencies is to use the MSYS2 . You can do so by performing the following steps: Download and run the installer - \"x86_64\" for 64-bit, \"i686\" for 32-bit Windows. Download Start MSYS2. Update the package database and core system packages with: pacman -Syu If needed, close MSYS2, run it again from Start menu. Update the rest with: pacman -Su Install dependencies: pacman -S git make python2 Download and install the GNU ARM Embedded Toolchain . The 6-2017-q2-update version is recommended. Run the installer and follow the given instructions. Upon completion, check the Add path to environment variable option. Then verify if the compiler works: arm-none-eabi-gcc --version Download the nRF5x-Command-Line-Tools for Win32 . Run the installer and follow the given instructions. Then verify if mergehex works: mergehex --version Install the latest stable version of pyOCD via pip as follows: pip install -U pyocd Type the following in your terminal to verify if pyocd works: pyocd --version Linux This section describes how to set up the development environment on Ubuntu. The steps should be similar for other Linux distributions. Ensure your host system is up to date before proceeding. sudo apt-get update sudo apt-get upgrade Install the following packages using your system\u2019s package manager. sudo apt-get install build-essential checkinstall Download and install the GNU ARM Embedded Toolchain . The 6-2017-q2-update version is recommended. Then ensure the path is added to your OS PATH environment variable. # in ~/.bash_profile, add the following script export PATH = path to install directory /gcc-arm-none-eabi-6-2017-q2-update/bin: ${ PATH } Type the following in your terminal to verify if the path is set correctly: arm-none-eabi-gcc --version Download the nRF5x-Command-Line-Tools-Linux-xxx , then extract the .tar archive anywhere on your filesystem. Ensure the extracted directory is added to your OS PATH environment variable. # in ~/.bash_profile, add the following script export PATH = the path to the extracted directory : ${ PATH } Type the following in your terminal to verify if mergehex works: mergehex --version Install the latest stable version of pyOCD via pip as follows: pip install -U pyocd Type the following in your terminal to verify if pyocd works: pyocd --version Clone the repository Clone the grove-mesh-kit repository from GitHub: git clone --recursive https://github.com/makerdiary/grove-mesh-kit Or if you have already cloned the project, you may update the submodule: git submodule update --init Install the nRF5 SDK Download the SDK file nRF5_SDK_v15.2.0_9412b96 from www.nordicsemi.com . Download Extract the zip file to the grove-mesh-kit repository. This should give you the following folder structure: ./grove-mesh-kit/ \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 README.md \u251c\u2500\u2500 config \u251c\u2500\u2500 docs \u251c\u2500\u2500 examples \u251c\u2500\u2500 firmware \u251c\u2500\u2500 mkdocs.yml \u2514\u2500\u2500 nrf_sdks \u251c\u2500\u2500 README.md \u251c\u2500\u2500 nRF5-SDK-for-Mesh \u2514\u2500\u2500 nRF5_SDK_v15.2.0_9412b96 To use the nRF5 SDK you first need to set the toolchain path in makefile.windows or makefile.posix depending on platform you are using. That is, the .posix should be edited if your are working on either Linux or macOS. These files are located in: nRF5 SDK /components/toolchain/gcc Open the file in a text editor ( Sublime is recommended), and make sure that the GNU_INSTALL_ROOT variable is pointing to your GNU Arm Embedded Toolchain install directory. GNU_INSTALL_ROOT ? = $( HOME ) /gcc-arm-none-eabi/gcc-arm-none-eabi-6-2017-q2-update/bin/ GNU_VERSION ? = 6 .3.1 GNU_PREFIX ? = arm-none-eabi Building the Grove CLI example Now you can try to build the Grove CLI example: Open terminal and change directory to: cd ./grove-mesh-kit/examples/grove_cli/armgcc/ Compile the example by running: make Running the Grove CLI example After compiling the source code, run the example: Connect the nRF52840-MDK board to your PC using the USB-C cable. Program the application and Softdevice by running: make flash_all Grove CLI will start automatically after programming. In Terminal, run: screen /dev/cu.usbmodem846fa1a9d0de1 115200 Type Enter and grove . Test functionality of each command. If you need a hint you can call commands with option -h or \u2013help . Alternatively, Web Device CLI is a better choice. Just start the Web Device CLI by clicking the following link: Start Web Device CLI Click the Connect button and pair the Grove CLI device. Just do it as you did in the terminal. Create an Issue Interested in contributing to this project? Want to report a bug? Feel free to click here: Create an Issue","title":"nRF5 SDK"},{"location":"setting-up-nrf5-sdk/#nrf5-sdk-offical-software-development-kit-for-nrf51-and-nrf52-series","text":"","title":"nRF5 SDK Offical Software Development Kit for nRF51 and nRF52 Series"},{"location":"setting-up-nrf5-sdk/#overview","text":"The nRF5 SDK is your first stop for building fully featured, reliable and secure applications with the nRF52 and nRF51 Series. It offers developers a wealth of varied modules and examples right across the spectrum including numerous Bluetooth Low Energy profiles, Device Firmware Upgrade (DFU), GATT serializer and driver support for all peripherals on all nRF5 Series devices. The nRF5 SDK will almost certainly have something for your needs in developing exciting yet robust wireless products. Follow this guide to set up a nRF5 SDK development environment on your system, and then build and run a sample application.","title":"Overview"},{"location":"setting-up-nrf5-sdk/#set-up-the-toolchain","text":"To build the nRF5 SDK examples, GNU ARM Embedded Toolchain is required. Follow one of the following guides for your host operating system: macOS Windows Linux","title":"Set up the toolchain"},{"location":"setting-up-nrf5-sdk/#macos","text":"GNU make is bundled with Xcode tools. Verify by running: make --v Download and install the GNU ARM Embedded Toolchain . The 6-2017-q2-update version is recommended. Then ensure the path is added to your OS PATH environment variable. # in ~/.bash_profile, add the following script export PATH = path to install directory /gcc-arm-none-eabi-6-2017-q2-update/bin: ${ PATH } Type the following in your terminal to verify if the path is set correctly: arm-none-eabi-gcc --version Download the nRF5x-Command-Line-Tools-OSX , then extract the .tar archive anywhere on your filesystem. Ensure the extracted directory is added to your OS PATH environment variable. # in ~/.bash_profile, add the following script export PATH = the path to the extracted directory : ${ PATH } Type the following in your terminal to verify if mergehex works: mergehex --version Install the latest stable version of pyOCD via pip as follows: pip install -U pyocd Type the following in your terminal to verify if pyocd works: pyocd --version","title":"macOS"},{"location":"setting-up-nrf5-sdk/#windows","text":"On Windows the easiest way to install the dependencies is to use the MSYS2 . You can do so by performing the following steps: Download and run the installer - \"x86_64\" for 64-bit, \"i686\" for 32-bit Windows. Download Start MSYS2. Update the package database and core system packages with: pacman -Syu If needed, close MSYS2, run it again from Start menu. Update the rest with: pacman -Su Install dependencies: pacman -S git make python2 Download and install the GNU ARM Embedded Toolchain . The 6-2017-q2-update version is recommended. Run the installer and follow the given instructions. Upon completion, check the Add path to environment variable option. Then verify if the compiler works: arm-none-eabi-gcc --version Download the nRF5x-Command-Line-Tools for Win32 . Run the installer and follow the given instructions. Then verify if mergehex works: mergehex --version Install the latest stable version of pyOCD via pip as follows: pip install -U pyocd Type the following in your terminal to verify if pyocd works: pyocd --version","title":"Windows"},{"location":"setting-up-nrf5-sdk/#linux","text":"This section describes how to set up the development environment on Ubuntu. The steps should be similar for other Linux distributions. Ensure your host system is up to date before proceeding. sudo apt-get update sudo apt-get upgrade Install the following packages using your system\u2019s package manager. sudo apt-get install build-essential checkinstall Download and install the GNU ARM Embedded Toolchain . The 6-2017-q2-update version is recommended. Then ensure the path is added to your OS PATH environment variable. # in ~/.bash_profile, add the following script export PATH = path to install directory /gcc-arm-none-eabi-6-2017-q2-update/bin: ${ PATH } Type the following in your terminal to verify if the path is set correctly: arm-none-eabi-gcc --version Download the nRF5x-Command-Line-Tools-Linux-xxx , then extract the .tar archive anywhere on your filesystem. Ensure the extracted directory is added to your OS PATH environment variable. # in ~/.bash_profile, add the following script export PATH = the path to the extracted directory : ${ PATH } Type the following in your terminal to verify if mergehex works: mergehex --version Install the latest stable version of pyOCD via pip as follows: pip install -U pyocd Type the following in your terminal to verify if pyocd works: pyocd --version","title":"Linux"},{"location":"setting-up-nrf5-sdk/#clone-the-repository","text":"Clone the grove-mesh-kit repository from GitHub: git clone --recursive https://github.com/makerdiary/grove-mesh-kit Or if you have already cloned the project, you may update the submodule: git submodule update --init","title":"Clone the repository"},{"location":"setting-up-nrf5-sdk/#install-the-nrf5-sdk","text":"Download the SDK file nRF5_SDK_v15.2.0_9412b96 from www.nordicsemi.com . Download Extract the zip file to the grove-mesh-kit repository. This should give you the following folder structure: ./grove-mesh-kit/ \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 README.md \u251c\u2500\u2500 config \u251c\u2500\u2500 docs \u251c\u2500\u2500 examples \u251c\u2500\u2500 firmware \u251c\u2500\u2500 mkdocs.yml \u2514\u2500\u2500 nrf_sdks \u251c\u2500\u2500 README.md \u251c\u2500\u2500 nRF5-SDK-for-Mesh \u2514\u2500\u2500 nRF5_SDK_v15.2.0_9412b96 To use the nRF5 SDK you first need to set the toolchain path in makefile.windows or makefile.posix depending on platform you are using. That is, the .posix should be edited if your are working on either Linux or macOS. These files are located in: nRF5 SDK /components/toolchain/gcc Open the file in a text editor ( Sublime is recommended), and make sure that the GNU_INSTALL_ROOT variable is pointing to your GNU Arm Embedded Toolchain install directory. GNU_INSTALL_ROOT ? = $( HOME ) /gcc-arm-none-eabi/gcc-arm-none-eabi-6-2017-q2-update/bin/ GNU_VERSION ? = 6 .3.1 GNU_PREFIX ? = arm-none-eabi","title":"Install the nRF5 SDK"},{"location":"setting-up-nrf5-sdk/#building-the-grove-cli-example","text":"Now you can try to build the Grove CLI example: Open terminal and change directory to: cd ./grove-mesh-kit/examples/grove_cli/armgcc/ Compile the example by running: make","title":"Building the Grove CLI example"},{"location":"setting-up-nrf5-sdk/#running-the-grove-cli-example","text":"After compiling the source code, run the example: Connect the nRF52840-MDK board to your PC using the USB-C cable. Program the application and Softdevice by running: make flash_all Grove CLI will start automatically after programming. In Terminal, run: screen /dev/cu.usbmodem846fa1a9d0de1 115200 Type Enter and grove . Test functionality of each command. If you need a hint you can call commands with option -h or \u2013help . Alternatively, Web Device CLI is a better choice. Just start the Web Device CLI by clicking the following link: Start Web Device CLI Click the Connect button and pair the Grove CLI device. Just do it as you did in the terminal.","title":"Running the Grove CLI example"},{"location":"setting-up-nrf5-sdk/#create-an-issue","text":"Interested in contributing to this project? Want to report a bug? Feel free to click here: Create an Issue","title":"Create an Issue"},{"location":"where-to-buy/","text":"Where to buy Buy a Grove Mesh Kit The Grove Mesh Kit is available at Seeed Studio (click to go directly to the product): Bulk Customization We are ready to customize our electronics and firmware to better meet your solution's needs. Many of our products are prepared for customization. If you would like to do some serious business, drop a line and we'll reply before you know it. Email Us","title":"Where to buy"},{"location":"where-to-buy/#where-to-buy","text":"","title":"Where to buy"},{"location":"where-to-buy/#buy-a-grove-mesh-kit","text":"The Grove Mesh Kit is available at Seeed Studio (click to go directly to the product):","title":"Buy a Grove Mesh Kit"},{"location":"where-to-buy/#bulk-customization","text":"We are ready to customize our electronics and firmware to better meet your solution's needs. Many of our products are prepared for customization. If you would like to do some serious business, drop a line and we'll reply before you know it. Email Us","title":"Bulk &amp; Customization"},{"location":"bluetooth-mesh/","text":"Bluetooth Mesh Network for Grove Mesh Kit Overview Mesh networking is a new topology available for Bluetooth Low Energy (BLE) devices that enables many-to-many (m:m) communications. It's optimized for creating large-scale node networks and is ideally suited for building automation, sensor networks, and asset tracking solutions. The Bluetooth Mesh Networking Specifications are developed and published by the Bluetooth SIG . They include: Mesh Profile : Defines fundamental requirements to enable an interoperable mesh networking solution for Bluetooth LE wireless technology Mesh Model : Introduces models , used to define basic functionality of nodes on a mesh network Mesh Device Properties : Defines device properties required for the Mesh Model specification More detailed information about Bluetooth Mesh is available in Bluetooth SIG's introduction to Bluetooth Mesh and the Bluetooth Mesh Networking Specifications . The nRF5 SDK for Mesh is Nordic Semiconductor's implementation of the Bluetooth Mesh. It allows applications to use the features provided by the Bluetooth Mesh when running on Nordic's nRF5 Series chips. Supported features The nRF5 SDK for Mesh supports all the mandatory features of the Mesh Profile Specification. These mandatory features are qualified. The following optional mesh features are supported by the nRF5 SDK for Mesh, but not qualified yet: Provisioning over GATT bearer GATT bearer Config client Mesh Proxy Service with Proxy Server Low Power feature Generic server and client models Resources nRF5 SDK for Mesh Documentation Basic Bluetooth Mesh Concepts nRF5 SDK for Mesh Architecture Create an Issue Interested in contributing to this project? Want to report a bug? Feel free to click here: Create an Issue","title":"Overview"},{"location":"bluetooth-mesh/#bluetooth-mesh-network-for-grove-mesh-kit","text":"","title":"Bluetooth Mesh Network for Grove Mesh Kit"},{"location":"bluetooth-mesh/#overview","text":"Mesh networking is a new topology available for Bluetooth Low Energy (BLE) devices that enables many-to-many (m:m) communications. It's optimized for creating large-scale node networks and is ideally suited for building automation, sensor networks, and asset tracking solutions. The Bluetooth Mesh Networking Specifications are developed and published by the Bluetooth SIG . They include: Mesh Profile : Defines fundamental requirements to enable an interoperable mesh networking solution for Bluetooth LE wireless technology Mesh Model : Introduces models , used to define basic functionality of nodes on a mesh network Mesh Device Properties : Defines device properties required for the Mesh Model specification More detailed information about Bluetooth Mesh is available in Bluetooth SIG's introduction to Bluetooth Mesh and the Bluetooth Mesh Networking Specifications . The nRF5 SDK for Mesh is Nordic Semiconductor's implementation of the Bluetooth Mesh. It allows applications to use the features provided by the Bluetooth Mesh when running on Nordic's nRF5 Series chips.","title":"Overview"},{"location":"bluetooth-mesh/#supported-features","text":"The nRF5 SDK for Mesh supports all the mandatory features of the Mesh Profile Specification. These mandatory features are qualified. The following optional mesh features are supported by the nRF5 SDK for Mesh, but not qualified yet: Provisioning over GATT bearer GATT bearer Config client Mesh Proxy Service with Proxy Server Low Power feature Generic server and client models","title":"Supported features"},{"location":"bluetooth-mesh/#resources","text":"nRF5 SDK for Mesh Documentation Basic Bluetooth Mesh Concepts nRF5 SDK for Mesh Architecture","title":"Resources"},{"location":"bluetooth-mesh/#create-an-issue","text":"Interested in contributing to this project? Want to report a bug? Feel free to click here: Create an Issue","title":"Create an Issue"},{"location":"bluetooth-mesh/building-n-running-the-examples/","text":"Building and Running the Mesh examples This section describes how to build the mesh library and example applications with CMake , and the run my light switch example. Before you start building, remember to set up the mesh development environment first. See Setting Up the Mesh SDK for details. Generating build files Good practice is to create a build folder in the grove-mesh-kit directory, where all artifacts generated by the Ninja build system are stored: Open terminal and change directory to: cd ./grove-mesh-kit Creat a build folder and change directory to it: mkdir build cd build Before you can build with Ninja, you must generate the correct build files with CMake. cmake -G Ninja -DTOOLCHAIN = gccarmemb -DPLATFORM = nrf52840_xxAA -DBOARD = nrf52840_mdk -DFLASHER = pyocd ../nrf_sdks/nRF5-SDK-for-Mesh/ Building the stack and examples After the Ninja build files are generated, running ninja target to build the targets. Here we take the target my_light_switch_client as an example: ninja my_light_switch_client_nrf52840_xxAA_s140_6.1.0 Other targets are ready for building. For example: ninja my_light_switch_server_nrf52840_xxAA_s140_6.1.0 ninja my_light_switch_provisioner_nrf52840_xxAA_s140_6.1.0 Running the example To run examples on your nRF52840-MDK, first connect it to your computer with a USB cable. When your board is detected, run ninja flash_ your target to flash the example: ninja flash_my_light_switch_client_nrf52840_xxAA_s140_6.1.0 Run a terminal application like PuTTY or screen to print the log information: screen /dev/cu.usbmodem141102 115200 Flash other nRF52840-MDK boards with Server target: ninja flash_my_light_switch_server_nrf52840_xxAA_s140_6.1.0 You can use the nRF Mesh mobile app to provision the client and server devices: Next Steps Congratulations! You may find your way around to build and run the mesh examples. And further more, you can create your own targets . Create an Issue Interested in contributing to this project? Want to report a bug? Feel free to click here: Create an Issue","title":"Building & Running the examples"},{"location":"bluetooth-mesh/building-n-running-the-examples/#building-and-running-the-mesh-examples","text":"This section describes how to build the mesh library and example applications with CMake , and the run my light switch example. Before you start building, remember to set up the mesh development environment first. See Setting Up the Mesh SDK for details.","title":"Building and Running the Mesh examples"},{"location":"bluetooth-mesh/building-n-running-the-examples/#generating-build-files","text":"Good practice is to create a build folder in the grove-mesh-kit directory, where all artifacts generated by the Ninja build system are stored: Open terminal and change directory to: cd ./grove-mesh-kit Creat a build folder and change directory to it: mkdir build cd build Before you can build with Ninja, you must generate the correct build files with CMake. cmake -G Ninja -DTOOLCHAIN = gccarmemb -DPLATFORM = nrf52840_xxAA -DBOARD = nrf52840_mdk -DFLASHER = pyocd ../nrf_sdks/nRF5-SDK-for-Mesh/","title":"Generating build files"},{"location":"bluetooth-mesh/building-n-running-the-examples/#building-the-stack-and-examples","text":"After the Ninja build files are generated, running ninja target to build the targets. Here we take the target my_light_switch_client as an example: ninja my_light_switch_client_nrf52840_xxAA_s140_6.1.0 Other targets are ready for building. For example: ninja my_light_switch_server_nrf52840_xxAA_s140_6.1.0 ninja my_light_switch_provisioner_nrf52840_xxAA_s140_6.1.0","title":"Building the stack and examples"},{"location":"bluetooth-mesh/building-n-running-the-examples/#running-the-example","text":"To run examples on your nRF52840-MDK, first connect it to your computer with a USB cable. When your board is detected, run ninja flash_ your target to flash the example: ninja flash_my_light_switch_client_nrf52840_xxAA_s140_6.1.0 Run a terminal application like PuTTY or screen to print the log information: screen /dev/cu.usbmodem141102 115200 Flash other nRF52840-MDK boards with Server target: ninja flash_my_light_switch_server_nrf52840_xxAA_s140_6.1.0 You can use the nRF Mesh mobile app to provision the client and server devices:","title":"Running the example"},{"location":"bluetooth-mesh/building-n-running-the-examples/#next-steps","text":"Congratulations! You may find your way around to build and run the mesh examples. And further more, you can create your own targets .","title":"Next Steps"},{"location":"bluetooth-mesh/building-n-running-the-examples/#create-an-issue","text":"Interested in contributing to this project? Want to report a bug? Feel free to click here: Create an Issue","title":"Create an Issue"},{"location":"bluetooth-mesh/creating-your-own-targets/","text":"Creating your own targets This section describes how to create a new build target for your own mesh application. Creating a new build target The easiest way to create a new build target is to: Copy one of the example folders in nRF5-SDK-for-Mesh , e.g., examples/my_beaconing to examples/my_app . Add the folder to the examples/CMakeLists.txt with a add_subdirectory(\"my_app\") command. Modify the target name in the first line of examples/my_app/CMakeLists.txt to set(target \"my_app\") . Open terminal and change directory to: cd ./grove-mesh-kit Creat a build folder and change directory to it: mkdir build cd build Generating build files with cmake -G Ninja -DTOOLCHAIN = gccarmemb -DPLATFORM = nrf52840_xxAA -DBOARD = nrf52840_mdk -DFLASHER = pyocd ../nrf_sdks/nRF5-SDK-for-Mesh/ Build your new target with: ninja my_app Flash the target: ninja flash_my_app API Reference Check out the Mesh API Reference for resources. Create an Issue Interested in contributing to this project? Want to report a bug? Feel free to click here: Create an Issue","title":"Creating your own targets"},{"location":"bluetooth-mesh/creating-your-own-targets/#creating-your-own-targets","text":"This section describes how to create a new build target for your own mesh application.","title":"Creating your own targets"},{"location":"bluetooth-mesh/creating-your-own-targets/#creating-a-new-build-target","text":"The easiest way to create a new build target is to: Copy one of the example folders in nRF5-SDK-for-Mesh , e.g., examples/my_beaconing to examples/my_app . Add the folder to the examples/CMakeLists.txt with a add_subdirectory(\"my_app\") command. Modify the target name in the first line of examples/my_app/CMakeLists.txt to set(target \"my_app\") . Open terminal and change directory to: cd ./grove-mesh-kit Creat a build folder and change directory to it: mkdir build cd build Generating build files with cmake -G Ninja -DTOOLCHAIN = gccarmemb -DPLATFORM = nrf52840_xxAA -DBOARD = nrf52840_mdk -DFLASHER = pyocd ../nrf_sdks/nRF5-SDK-for-Mesh/ Build your new target with: ninja my_app Flash the target: ninja flash_my_app","title":"Creating a new build target"},{"location":"bluetooth-mesh/creating-your-own-targets/#api-reference","text":"Check out the Mesh API Reference for resources.","title":"API Reference"},{"location":"bluetooth-mesh/creating-your-own-targets/#create-an-issue","text":"Interested in contributing to this project? Want to report a bug? Feel free to click here: Create an Issue","title":"Create an Issue"},{"location":"bluetooth-mesh/getting-started/","text":"Getting started with Bluetooth Mesh Network This section describes how to quickly build a Bluetooth Mesh network using my light switch example without going through the complete toolchain installation. There is no need to build any firmware for running it, as it uses the pre-built firmware of my light switch example. Hardware Requirements A minimal Bluetooth Mesh network requires at least One client, Two servers and One provisioner. Before starting to work, prepare the following parts: Grove Mesh Kit for nRF52840-MDK * 3 Three AA batteries( Energizer\u00ae Ultimate Lithium\u2122 AA battery is recommended to stay powered longer.) A phone with nRF Mesh mobile app ( iOS or Android ) installed Assembling the hardware Place the nRF52840-MDK board onto the Base Dock Connect the Grove - Button to PORT#1 on the Base Dock Attach the four plastic spacers supplied in your box to act as legs for the Base Dock Insert an AA battery into the holder the right way around as marked on the board Tip AA battery is NOT included in the kit. The Energizer\u00ae Ultimate Lithium\u2122 AA battery is recommended to stay powered longer. Flashing the example firmware Before running my light switch example, you need to flash the boards. The pre-built firmware is located in grove-mesh-kit/firmware/bluetooth-mesh/my_light_switch : For Client: my_light_switch_client_nrf52840_xxAA_s140_6.1.0_merged.hex For Servers: my_light_switch_server_nrf52840_xxAA_s140_6.1.0_merged.hex Tip The provisioner firmware is not used here. The nRF Mesh app is used instead to provision the devices. Connect one nRF52840-MDK board to your PC using the USB-C cable. A removable drive named DAPLINK will appear. Drag and drop the pre-built client firmware into DAPLINK . After flashed, label the board Client so that later you don't confuse the board roles. Program the rest two boards with the pre-build server firmware. And label them Server#1 and Server#2 . Tip You can also program the board using pyOCD . Just follow this tutorial to set up the pyOCD tool. Provisioning the devices To participate in mesh communication, each device must be provisioned. Provisioning is the act of adding a device to a mesh network. Through the provisioning process, the new device receives a range of addresses, a network key, and a device key. Here we use the nRF Mesh mobile app to provision the client and server devices: Power up the client and servers Launch the nRF Mesh mobile app. In Network tab, click + button to scan the devices. The client is recognized as nRF5x Mesh Switch and the servers are recognized as nRF5x Mesh Light . Tap nRF5x Mesh Switch , and then go to the Provisioning Data configurations. Give the node a friendly name, such as Living Room Switch . Upon tapping IDENTIFY , the LED is blinking blue. Tap PROVISION and select No OOB type to finish provisioning. Tap \u2699 to configure the Living Room Switch . You will see two Generic On Off Client elements. Bind them with the same app key. Set the publish address of the first Generic On Off Client to 0xCAFE and the second one to 0xCAFF . The publish addresses can be subscribed by the servers. Tap nRF5x Mesh Light and go to the Provisioning Data configurations. Name the nodes Living Room Light 1 and Living Room Light 2 . Go ahead to finish provisioning. Tap \u2699 to configure the Living Room Light 1 and Living Room Light 2 . Bind the Generic On Off Server with the same app key as the client. Set the subscribe address to the client's publish address 0xCAFE or 0xCAFF . Testing the mesh network Now you have set up a Bluetooth mesh network with one client node and two server nodes. Try to press the buttons on the client to see the LEDs getting toggled on the associated servers. Next Steps See the Setting Up the Mesh SDK section for information on environment setup. Once you set up your nRF5 SDK for Mesh environment, see the Building Running the examples to build the examples on your own machine. And further more, you can create your own targets . Create an Issue Interested in contributing to this project? Want to report a bug? Feel free to click here: Create an Issue","title":"Getting Started"},{"location":"bluetooth-mesh/getting-started/#getting-started-with-bluetooth-mesh-network","text":"This section describes how to quickly build a Bluetooth Mesh network using my light switch example without going through the complete toolchain installation. There is no need to build any firmware for running it, as it uses the pre-built firmware of my light switch example.","title":"Getting started with Bluetooth Mesh Network"},{"location":"bluetooth-mesh/getting-started/#hardware-requirements","text":"A minimal Bluetooth Mesh network requires at least One client, Two servers and One provisioner. Before starting to work, prepare the following parts: Grove Mesh Kit for nRF52840-MDK * 3 Three AA batteries( Energizer\u00ae Ultimate Lithium\u2122 AA battery is recommended to stay powered longer.) A phone with nRF Mesh mobile app ( iOS or Android ) installed","title":"Hardware Requirements"},{"location":"bluetooth-mesh/getting-started/#assembling-the-hardware","text":"Place the nRF52840-MDK board onto the Base Dock Connect the Grove - Button to PORT#1 on the Base Dock Attach the four plastic spacers supplied in your box to act as legs for the Base Dock Insert an AA battery into the holder the right way around as marked on the board Tip AA battery is NOT included in the kit. The Energizer\u00ae Ultimate Lithium\u2122 AA battery is recommended to stay powered longer.","title":"Assembling the hardware"},{"location":"bluetooth-mesh/getting-started/#flashing-the-example-firmware","text":"Before running my light switch example, you need to flash the boards. The pre-built firmware is located in grove-mesh-kit/firmware/bluetooth-mesh/my_light_switch : For Client: my_light_switch_client_nrf52840_xxAA_s140_6.1.0_merged.hex For Servers: my_light_switch_server_nrf52840_xxAA_s140_6.1.0_merged.hex Tip The provisioner firmware is not used here. The nRF Mesh app is used instead to provision the devices. Connect one nRF52840-MDK board to your PC using the USB-C cable. A removable drive named DAPLINK will appear. Drag and drop the pre-built client firmware into DAPLINK . After flashed, label the board Client so that later you don't confuse the board roles. Program the rest two boards with the pre-build server firmware. And label them Server#1 and Server#2 . Tip You can also program the board using pyOCD . Just follow this tutorial to set up the pyOCD tool.","title":"Flashing the example firmware"},{"location":"bluetooth-mesh/getting-started/#provisioning-the-devices","text":"To participate in mesh communication, each device must be provisioned. Provisioning is the act of adding a device to a mesh network. Through the provisioning process, the new device receives a range of addresses, a network key, and a device key. Here we use the nRF Mesh mobile app to provision the client and server devices: Power up the client and servers Launch the nRF Mesh mobile app. In Network tab, click + button to scan the devices. The client is recognized as nRF5x Mesh Switch and the servers are recognized as nRF5x Mesh Light . Tap nRF5x Mesh Switch , and then go to the Provisioning Data configurations. Give the node a friendly name, such as Living Room Switch . Upon tapping IDENTIFY , the LED is blinking blue. Tap PROVISION and select No OOB type to finish provisioning. Tap \u2699 to configure the Living Room Switch . You will see two Generic On Off Client elements. Bind them with the same app key. Set the publish address of the first Generic On Off Client to 0xCAFE and the second one to 0xCAFF . The publish addresses can be subscribed by the servers. Tap nRF5x Mesh Light and go to the Provisioning Data configurations. Name the nodes Living Room Light 1 and Living Room Light 2 . Go ahead to finish provisioning. Tap \u2699 to configure the Living Room Light 1 and Living Room Light 2 . Bind the Generic On Off Server with the same app key as the client. Set the subscribe address to the client's publish address 0xCAFE or 0xCAFF .","title":"Provisioning the devices"},{"location":"bluetooth-mesh/getting-started/#testing-the-mesh-network","text":"Now you have set up a Bluetooth mesh network with one client node and two server nodes. Try to press the buttons on the client to see the LEDs getting toggled on the associated servers.","title":"Testing the mesh network"},{"location":"bluetooth-mesh/getting-started/#next-steps","text":"See the Setting Up the Mesh SDK section for information on environment setup. Once you set up your nRF5 SDK for Mesh environment, see the Building Running the examples to build the examples on your own machine. And further more, you can create your own targets .","title":"Next Steps"},{"location":"bluetooth-mesh/getting-started/#create-an-issue","text":"Interested in contributing to this project? Want to report a bug? Feel free to click here: Create an Issue","title":"Create an Issue"},{"location":"bluetooth-mesh/license/","text":"License The nRF5 SDK for Mesh has been released by Nordic Semiconductor . Detailed license terms are as follows. nRF5 SDK for Mesh License The Grove Mesh Kit has been released as open source under the MIT License. Detailed license terms are as follows. MIT License Create an Issue Interested in contributing to this project? Want to report a bug? Feel free to click here: Create an Issue","title":"License"},{"location":"bluetooth-mesh/license/#license","text":"The nRF5 SDK for Mesh has been released by Nordic Semiconductor . Detailed license terms are as follows. nRF5 SDK for Mesh License The Grove Mesh Kit has been released as open source under the MIT License. Detailed license terms are as follows. MIT License","title":"License"},{"location":"bluetooth-mesh/license/#create-an-issue","text":"Interested in contributing to this project? Want to report a bug? Feel free to click here: Create an Issue","title":"Create an Issue"},{"location":"bluetooth-mesh/setting-up-the-mesh-sdk/","text":"Setting Up the nRF5 SDK for Mesh Environment This section describes how to set up the nRF5 SDK for Mesh development environment on your host operating system. Set up the toolchain To build the Mesh applications, a toolchain based on CMake is required. Follow one of the following guides for your host operating system: macOS Windows Linux macOS Install Homebrew by following instructions on the Homebrew site . Install CMake and Ninja using brew : brew install cmake ninja Download and install the GNU ARM Embedded Toolchain . The 6-2017-q2-update version is recommended. Then ensure the path is added to your OS PATH environment variable. # in ~/.bash_profile, add the following script export PATH = path to install directory /gcc-arm-none-eabi-6-2017-q2-update/bin: ${ PATH } Type the following in your terminal to verify if the path is set correctly: arm-none-eabi-gcc --version Download the nRF5x-Command-Line-Tools-OSX , then extract the .tar archive anywhere on your filesystem. Ensure the extracted directory is added to your OS PATH environment variable. # in ~/.bash_profile, add the following script export PATH = the path to the extracted directory : ${ PATH } Type the following in your terminal to verify if mergehex works: mergehex --version Install the latest stable version of pyOCD via pip as follows: pip install -U pyocd Type the following in your terminal to verify if pyocd works: pyocd --version Windows The easiest way to install the native Windows dependencies is to first install Chocolatey , a package manager for Windows. If you prefer to install dependencies manually, you can also download the required programs from their respective websites. Install Chocolatey by following the instructions on the Chocolatey install page. Open a command prompt ( cmd.exe ) as an Administrator Optionally disable global confirmation to avoid having to confirm installation of individual programs: choco feature enable -n allowGlobalConfirmation Install CMake : choco install cmake --installargs ADD_CMAKE_TO_PATH=System Install the rest of the tools, and close the Administrator command prompt window when finished. choco install git python ninja Download and install the GNU ARM Embedded Toolchain . The 6-2017-q2-update version is recommended. Run the installer and follow the given instructions. Upon completion, check the Add path to environment variable option. Then verify if the compiler works: arm-none-eabi-gcc --version Download the nRF5x-Command-Line-Tools for Win32 . Run the installer and follow the given instructions. Then verify if mergehex works: mergehex --version Install the latest stable version of pyOCD via pip as follows: pip install -U pyocd Type the following in your terminal to verify if pyocd works: pyocd --version Linux This section describes how to set up the development environment on Ubuntu. The steps should be similar for other Linux distributions. Ensure your host system is up to date before proceeding. sudo apt-get update sudo apt-get upgrade Install the following packages using your system\u2019s package manager. sudo apt-get install --no-install-recommends git cmake ninja-build python3-pip Download and install the GNU ARM Embedded Toolchain . The 6-2017-q2-update version is recommended. Then ensure the path is added to your OS PATH environment variable. # in ~/.bash_profile, add the following script export PATH = path to install directory /gcc-arm-none-eabi-6-2017-q2-update/bin: ${ PATH } Type the following in your terminal to verify if the path is set correctly: arm-none-eabi-gcc --version Download the nRF5x-Command-Line-Tools-Linux-xxx , then extract the .tar archive anywhere on your filesystem. Ensure the extracted directory is added to your OS PATH environment variable. # in ~/.bash_profile, add the following script export PATH = the path to the extracted directory : ${ PATH } Type the following in your terminal to verify if mergehex works: mergehex --version Install the latest stable version of pyOCD via pip as follows: pip install -U pyocd Type the following in your terminal to verify if pyocd works: pyocd --version Clone the repository Clone the grove-mesh-kit repository from GitHub: git clone --recursive https://github.com/makerdiary/grove-mesh-kit Or if you have already cloned the project, you may update the submodule: git submodule update --init Install the nRF5 SDK The nRF5 SDK for Mesh now requires the nRF5 SDK to compile. Download the SDK file nRF5_SDK_v15.2.0_9412b96 from www.nordicsemi.com . Download Extract the zip file to the grove-mesh-kit repository. This should give you the following folder structure: ./grove-mesh-kit/ \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 README.md \u251c\u2500\u2500 config \u251c\u2500\u2500 docs \u251c\u2500\u2500 examples \u251c\u2500\u2500 firmware \u251c\u2500\u2500 mkdocs.yml \u2514\u2500\u2500 nrf_sdks \u251c\u2500\u2500 README.md \u251c\u2500\u2500 nRF5-SDK-for-Mesh \u2514\u2500\u2500 nRF5_SDK_v15.2.0_9412b96 To use the nRF5 SDK you first need to set the toolchain path in makefile.windows or makefile.posix depending on platform you are using. That is, the .posix should be edited if your are working on either Linux or macOS. These files are located in: nRF5 SDK /components/toolchain/gcc Open the file in a text editor ( Sublime is recommended), and make sure that the GNU_INSTALL_ROOT variable is pointing to your GNU Arm Embedded Toolchain install directory. GNU_INSTALL_ROOT ? = $( HOME ) /gcc-arm-none-eabi/gcc-arm-none-eabi-6-2017-q2-update/bin/ GNU_VERSION ? = 6 .3.1 GNU_PREFIX ? = arm-none-eabi Next Steps Congratulations! Now you can try to build and run the mesh examples. Head to Building Running the examples section for more details. Create an Issue Interested in contributing to this project? Want to report a bug? Feel free to click here: Create an Issue","title":"Setting Up the Mesh SDK"},{"location":"bluetooth-mesh/setting-up-the-mesh-sdk/#setting-up-the-nrf5-sdk-for-mesh-environment","text":"This section describes how to set up the nRF5 SDK for Mesh development environment on your host operating system.","title":"Setting Up the nRF5 SDK for Mesh Environment"},{"location":"bluetooth-mesh/setting-up-the-mesh-sdk/#set-up-the-toolchain","text":"To build the Mesh applications, a toolchain based on CMake is required. Follow one of the following guides for your host operating system: macOS Windows Linux","title":"Set up the toolchain"},{"location":"bluetooth-mesh/setting-up-the-mesh-sdk/#macos","text":"Install Homebrew by following instructions on the Homebrew site . Install CMake and Ninja using brew : brew install cmake ninja Download and install the GNU ARM Embedded Toolchain . The 6-2017-q2-update version is recommended. Then ensure the path is added to your OS PATH environment variable. # in ~/.bash_profile, add the following script export PATH = path to install directory /gcc-arm-none-eabi-6-2017-q2-update/bin: ${ PATH } Type the following in your terminal to verify if the path is set correctly: arm-none-eabi-gcc --version Download the nRF5x-Command-Line-Tools-OSX , then extract the .tar archive anywhere on your filesystem. Ensure the extracted directory is added to your OS PATH environment variable. # in ~/.bash_profile, add the following script export PATH = the path to the extracted directory : ${ PATH } Type the following in your terminal to verify if mergehex works: mergehex --version Install the latest stable version of pyOCD via pip as follows: pip install -U pyocd Type the following in your terminal to verify if pyocd works: pyocd --version","title":"macOS"},{"location":"bluetooth-mesh/setting-up-the-mesh-sdk/#windows","text":"The easiest way to install the native Windows dependencies is to first install Chocolatey , a package manager for Windows. If you prefer to install dependencies manually, you can also download the required programs from their respective websites. Install Chocolatey by following the instructions on the Chocolatey install page. Open a command prompt ( cmd.exe ) as an Administrator Optionally disable global confirmation to avoid having to confirm installation of individual programs: choco feature enable -n allowGlobalConfirmation Install CMake : choco install cmake --installargs ADD_CMAKE_TO_PATH=System Install the rest of the tools, and close the Administrator command prompt window when finished. choco install git python ninja Download and install the GNU ARM Embedded Toolchain . The 6-2017-q2-update version is recommended. Run the installer and follow the given instructions. Upon completion, check the Add path to environment variable option. Then verify if the compiler works: arm-none-eabi-gcc --version Download the nRF5x-Command-Line-Tools for Win32 . Run the installer and follow the given instructions. Then verify if mergehex works: mergehex --version Install the latest stable version of pyOCD via pip as follows: pip install -U pyocd Type the following in your terminal to verify if pyocd works: pyocd --version","title":"Windows"},{"location":"bluetooth-mesh/setting-up-the-mesh-sdk/#linux","text":"This section describes how to set up the development environment on Ubuntu. The steps should be similar for other Linux distributions. Ensure your host system is up to date before proceeding. sudo apt-get update sudo apt-get upgrade Install the following packages using your system\u2019s package manager. sudo apt-get install --no-install-recommends git cmake ninja-build python3-pip Download and install the GNU ARM Embedded Toolchain . The 6-2017-q2-update version is recommended. Then ensure the path is added to your OS PATH environment variable. # in ~/.bash_profile, add the following script export PATH = path to install directory /gcc-arm-none-eabi-6-2017-q2-update/bin: ${ PATH } Type the following in your terminal to verify if the path is set correctly: arm-none-eabi-gcc --version Download the nRF5x-Command-Line-Tools-Linux-xxx , then extract the .tar archive anywhere on your filesystem. Ensure the extracted directory is added to your OS PATH environment variable. # in ~/.bash_profile, add the following script export PATH = the path to the extracted directory : ${ PATH } Type the following in your terminal to verify if mergehex works: mergehex --version Install the latest stable version of pyOCD via pip as follows: pip install -U pyocd Type the following in your terminal to verify if pyocd works: pyocd --version","title":"Linux"},{"location":"bluetooth-mesh/setting-up-the-mesh-sdk/#clone-the-repository","text":"Clone the grove-mesh-kit repository from GitHub: git clone --recursive https://github.com/makerdiary/grove-mesh-kit Or if you have already cloned the project, you may update the submodule: git submodule update --init","title":"Clone the repository"},{"location":"bluetooth-mesh/setting-up-the-mesh-sdk/#install-the-nrf5-sdk","text":"The nRF5 SDK for Mesh now requires the nRF5 SDK to compile. Download the SDK file nRF5_SDK_v15.2.0_9412b96 from www.nordicsemi.com . Download Extract the zip file to the grove-mesh-kit repository. This should give you the following folder structure: ./grove-mesh-kit/ \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 README.md \u251c\u2500\u2500 config \u251c\u2500\u2500 docs \u251c\u2500\u2500 examples \u251c\u2500\u2500 firmware \u251c\u2500\u2500 mkdocs.yml \u2514\u2500\u2500 nrf_sdks \u251c\u2500\u2500 README.md \u251c\u2500\u2500 nRF5-SDK-for-Mesh \u2514\u2500\u2500 nRF5_SDK_v15.2.0_9412b96 To use the nRF5 SDK you first need to set the toolchain path in makefile.windows or makefile.posix depending on platform you are using. That is, the .posix should be edited if your are working on either Linux or macOS. These files are located in: nRF5 SDK /components/toolchain/gcc Open the file in a text editor ( Sublime is recommended), and make sure that the GNU_INSTALL_ROOT variable is pointing to your GNU Arm Embedded Toolchain install directory. GNU_INSTALL_ROOT ? = $( HOME ) /gcc-arm-none-eabi/gcc-arm-none-eabi-6-2017-q2-update/bin/ GNU_VERSION ? = 6 .3.1 GNU_PREFIX ? = arm-none-eabi","title":"Install the nRF5 SDK"},{"location":"bluetooth-mesh/setting-up-the-mesh-sdk/#next-steps","text":"Congratulations! Now you can try to build and run the mesh examples. Head to Building Running the examples section for more details.","title":"Next Steps"},{"location":"bluetooth-mesh/setting-up-the-mesh-sdk/#create-an-issue","text":"Interested in contributing to this project? Want to report a bug? Feel free to click here: Create an Issue","title":"Create an Issue"},{"location":"openthread-mesh/","text":"OpenThread Mesh Network for Grove Mesh Kit Overview OpenThread is a portable and flexible open-source implementation of the Thread\u00ae networking protocol, created by Nest in active collaboration with Nordic to accelerate the development of products for the connected home. Features OpenThread implements all Thread networking layers (IPv6, 6LoWPAN, IEEE 802.15.4 with MAC security, Mesh Link Establishment, Mesh Routing) and device roles, as well as Border Router support. Application Services IPv6 configuration and raw data interface UDP sockets CoAP client and server DHCPv6 client and server DNSv6 client Enhanced Features Child Supervision Inform Previous Parent on Reattach Jam Detection Periodic Parent Search NCP Support Spinel , a general purpose NCP protocol wpantund , a user-space NCP network interface driver/daemon Sniffer support via NCP Spinel nodes Border Router Web UI for configuration and management Thread Border Agent to support an External Commissioner NAT64 for connecting to IPv4 networks Thread interface driver using wpantund OpenThread Architecture OpenThread's portable nature makes no assumptions about platform features. OpenThread provides the hooks to utilize enhanced radio and crypto features, reducing system requirements, such as memory, code, and compute cycles. This can be done per platform, while retaining the ability to default to a standard configuration. See OpenThread platform designs for more information. Resources OpenThread GitHub repository openthread.io nRF5 SDK for Thread Documentation License Portions of this page are reproduced from work created and shared by Google and used according to terms described in the Creative Commons 3.0 Attribution License . Thread is a registered trademark of the Thread Group, Inc. Create an Issue Interested in contributing to this project? Want to report a bug? Feel free to click here: Create an Issue","title":"Overview"},{"location":"openthread-mesh/#openthread-mesh-network-for-grove-mesh-kit","text":"","title":"OpenThread Mesh Network for Grove Mesh Kit"},{"location":"openthread-mesh/#overview","text":"OpenThread is a portable and flexible open-source implementation of the Thread\u00ae networking protocol, created by Nest in active collaboration with Nordic to accelerate the development of products for the connected home.","title":"Overview"},{"location":"openthread-mesh/#features","text":"OpenThread implements all Thread networking layers (IPv6, 6LoWPAN, IEEE 802.15.4 with MAC security, Mesh Link Establishment, Mesh Routing) and device roles, as well as Border Router support. Application Services IPv6 configuration and raw data interface UDP sockets CoAP client and server DHCPv6 client and server DNSv6 client Enhanced Features Child Supervision Inform Previous Parent on Reattach Jam Detection Periodic Parent Search NCP Support Spinel , a general purpose NCP protocol wpantund , a user-space NCP network interface driver/daemon Sniffer support via NCP Spinel nodes Border Router Web UI for configuration and management Thread Border Agent to support an External Commissioner NAT64 for connecting to IPv4 networks Thread interface driver using wpantund","title":"Features"},{"location":"openthread-mesh/#openthread-architecture","text":"OpenThread's portable nature makes no assumptions about platform features. OpenThread provides the hooks to utilize enhanced radio and crypto features, reducing system requirements, such as memory, code, and compute cycles. This can be done per platform, while retaining the ability to default to a standard configuration. See OpenThread platform designs for more information.","title":"OpenThread Architecture"},{"location":"openthread-mesh/#resources","text":"OpenThread GitHub repository openthread.io nRF5 SDK for Thread Documentation","title":"Resources"},{"location":"openthread-mesh/#license","text":"Portions of this page are reproduced from work created and shared by Google and used according to terms described in the Creative Commons 3.0 Attribution License . Thread is a registered trademark of the Thread Group, Inc.","title":"License"},{"location":"openthread-mesh/#create-an-issue","text":"Interested in contributing to this project? Want to report a bug? Feel free to click here: Create an Issue","title":"Create an Issue"},{"location":"openthread-mesh/building-n-running-the-examples/","text":"Building and Running the OpenThread examples This section describes how to build the OpenThread library and example applications with the nRF5 SDK for Thread. Before you start building, remember to set up the Thread development environment first. See Setting Up the Thread SDK for details. Build the OpenThread libraries Before building the OpenThread examples, you first need to build the OpenThread libraries. Open terminal and change directory to: cd ./grove-mesh-kit/deps/openthread To install the dependencies, run: ./bootstrap Always clean the repo of previous builds first by running make clean : make -f examples/Makefile-nrf52840 clean For UART transport , run the following command. This allows you to communicate with the nRF52840 chip over UART interface. make -f examples/Makefile-nrf52840 BORDER_AGENT = 1 BORDER_ROUTER = 1 COAP = 1 COMMISSIONER = 1 DNS_CLIENT = 1 JOINER = 1 LINK_RAW = 1 MAC_FILTER = 1 MTD_NETDIAG = 1 SERVICE = 1 UDP_FORWARD = 1 ECDSA = 1 SNTP_CLIENT = 1 COAPS = 1 Alternatively, if you want to use the USB transport , run the command below: make -f examples/Makefile-nrf52840 BORDER_AGENT = 1 BORDER_ROUTER = 1 COAP = 1 COMMISSIONER = 1 DNS_CLIENT = 1 JOINER = 1 LINK_RAW = 1 MAC_FILTER = 1 MTD_NETDIAG = 1 SERVICE = 1 UDP_FORWARD = 1 ECDSA = 1 SNTP_CLIENT = 1 COAPS = 1 USB = 1 Build the OpenThread CLI Now it's ready to build the OpenThread CLI example. The example is located in grove-mesh-kit/examples/thread/cli . Navigate to the directory with the OpenThread Full Thread Device (FTD) CLI Makefile: cd ./grove-mesh-kit/examples/thread/cli/ftd/uart/armgcc Run make to build the example: make Run the OpenThread CLI To run the OpenThread CLI on your nRF52840-MDK, first connect it to your computer with a USB cable. When your board is detected, run make flash to flash the example: make flash Run a terminal application like PuTTY or screen to configure the device: screen /dev/cu.usbmodem141102 115200 Program the rest boards by repeating steps as described above. To test the example, follow the Running the OpenThread CLI section. Next Steps You can check out other Thread examples located in grove-mesh-kit/examples/thread . And further more, you can follow the tutorials to Build an OpenThread Border Router with Raspberry Pi , or Make an OpenThread Network Sniffer to sniff packets on a Thread network. Create an Issue Interested in contributing to this project? Want to report a bug? Feel free to click here: Create an Issue","title":"Building & Running the examples"},{"location":"openthread-mesh/building-n-running-the-examples/#building-and-running-the-openthread-examples","text":"This section describes how to build the OpenThread library and example applications with the nRF5 SDK for Thread. Before you start building, remember to set up the Thread development environment first. See Setting Up the Thread SDK for details.","title":"Building and Running the OpenThread examples"},{"location":"openthread-mesh/building-n-running-the-examples/#build-the-openthread-libraries","text":"Before building the OpenThread examples, you first need to build the OpenThread libraries. Open terminal and change directory to: cd ./grove-mesh-kit/deps/openthread To install the dependencies, run: ./bootstrap Always clean the repo of previous builds first by running make clean : make -f examples/Makefile-nrf52840 clean For UART transport , run the following command. This allows you to communicate with the nRF52840 chip over UART interface. make -f examples/Makefile-nrf52840 BORDER_AGENT = 1 BORDER_ROUTER = 1 COAP = 1 COMMISSIONER = 1 DNS_CLIENT = 1 JOINER = 1 LINK_RAW = 1 MAC_FILTER = 1 MTD_NETDIAG = 1 SERVICE = 1 UDP_FORWARD = 1 ECDSA = 1 SNTP_CLIENT = 1 COAPS = 1 Alternatively, if you want to use the USB transport , run the command below: make -f examples/Makefile-nrf52840 BORDER_AGENT = 1 BORDER_ROUTER = 1 COAP = 1 COMMISSIONER = 1 DNS_CLIENT = 1 JOINER = 1 LINK_RAW = 1 MAC_FILTER = 1 MTD_NETDIAG = 1 SERVICE = 1 UDP_FORWARD = 1 ECDSA = 1 SNTP_CLIENT = 1 COAPS = 1 USB = 1","title":"Build the OpenThread libraries"},{"location":"openthread-mesh/building-n-running-the-examples/#build-the-openthread-cli","text":"Now it's ready to build the OpenThread CLI example. The example is located in grove-mesh-kit/examples/thread/cli . Navigate to the directory with the OpenThread Full Thread Device (FTD) CLI Makefile: cd ./grove-mesh-kit/examples/thread/cli/ftd/uart/armgcc Run make to build the example: make","title":"Build the OpenThread CLI"},{"location":"openthread-mesh/building-n-running-the-examples/#run-the-openthread-cli","text":"To run the OpenThread CLI on your nRF52840-MDK, first connect it to your computer with a USB cable. When your board is detected, run make flash to flash the example: make flash Run a terminal application like PuTTY or screen to configure the device: screen /dev/cu.usbmodem141102 115200 Program the rest boards by repeating steps as described above. To test the example, follow the Running the OpenThread CLI section.","title":"Run the OpenThread CLI"},{"location":"openthread-mesh/building-n-running-the-examples/#next-steps","text":"You can check out other Thread examples located in grove-mesh-kit/examples/thread . And further more, you can follow the tutorials to Build an OpenThread Border Router with Raspberry Pi , or Make an OpenThread Network Sniffer to sniff packets on a Thread network.","title":"Next Steps"},{"location":"openthread-mesh/building-n-running-the-examples/#create-an-issue","text":"Interested in contributing to this project? Want to report a bug? Feel free to click here: Create an Issue","title":"Create an Issue"},{"location":"openthread-mesh/getting-started/","text":"Getting started with OpenThread Mesh Network This section describes how to quickly run an OpenThread Mesh example without going through the complete toolchain installation. There is no need to build any firmware for running it, as it uses the pre-built firmware of OpenThread CLI example. This example application demonstrates a minimal OpenThread application that exposes the OpenThread configuration and management interfaces via a basic command-line interface. Hardware Requirements A minimal OpenThread Mesh network requires at least three nodes. Before starting to work, prepare the following parts: Grove Mesh Kit for nRF52840-MDK * 3 Three AA batteries( Energizer\u00ae Ultimate Lithium\u2122 AA battery is recommended to stay powered longer.) A macOS, Linux or Windows computer. Assembling the hardware Place the nRF52840-MDK board onto the Base Dock Attach the four plastic spacers supplied in your box to act as legs for the Base Dock Insert an AA battery into the holder the right way around as marked on the board Tip AA battery is NOT included in the kit. An Energizer\u00ae Ultimate Lithium\u2122 AA battery is recommended to stay powered longer. Flashing the OpenThread CLI Before running the OpenThread CLI example, you need to flash the boards. The pre-built firmware is located in grove-mesh-kit/firmware/openthread/cli : OpenThread CLI firmware Connect one nRF52840-MDK board to your PC using the USB-C cable. A removable drive named DAPLINK will appear. Drag and drop the pre-built cli firmware thread_cli_ftd_uart_nrf52840_mdk.hex into DAPLINK . After flashed, label the board Node#1 so that later you don't confuse the boards. Program the rest two boards by repeating steps as described above. Label them Node#2 and Node#3 Tip You can also program the board using pyOCD . Just follow this tutorial to set up the pyOCD tool. Running the OpenThread CLI You can access the OpenThread CLI by using a serial terminal like screen or PuTTY . Start Node#1 Open a terminal window and run: screen /dev/cu.usbmodem141102 115200 where /dev/cu.usbmodem141102 is the serial port name of Node#1. press Enter on the keyboard to bring up the OpenThread CLI prompt. Set the PAN ID: panid 0x1234 Bring up the IPv6 interface: ifconfig up Start Thread protocol operation: thread start The LED starts blinking GREEN. Wait a few seconds and verify that the device has become a Thread Leader: state leader Done Start the rest nodes Start the rest nodes by repeating steps as described above. Wait a minute and verify that the devices have become a Thread Router and a child: Node#2: state router Done Node#3: state child Done Ping the nodes View IPv6 addresses assigned to Node#2 and Node#3's Thread interface: Node#2: ipaddr fdde:ad00:beef:0:0:ff:fe00:9c00 fdde:ad00:beef:0:5748:44eb:b417:6d79 fe80:0:0:0:80c:e2b5:510b:8543 Done Node#3: ipaddr fdde:ad00:beef:0:0:ff:fe00:8000 fdde:ad00:beef:0:d675:a24e:2320:a5a3 fe80:0:0:0:d00a:c9f8:1e0a:dcb0 Done Ping Node#2 and Node#3 from Node#1(the leader): ping fdde:ad00:beef:0:5748:44eb:b417:6d79 16 bytes from fdde:ad00:beef:0:5748:44eb:b417:6d79: icmp_seq = 1 hlim = 64 time = 10ms ping fdde:ad00:beef:0:d675:a24e:2320:a5a3 16 bytes from fdde:ad00:beef:0:d675:a24e:2320:a5a3: icmp_seq = 2 hlim = 64 time = 39ms Next Steps Congratulations! You have built a simple OpenThread Mesh network with three nodes. You may use the CLI to change network parameters, other configurations, and perform other operations. See the OpenThread CLI Reference README.md to explore more. See the Setting Up the Thread SDK section for information on environment setup. Once you set up your Thread development environment, see the Building Running the examples to build the examples on your own machine. Create an Issue Interested in contributing to this project? Want to report a bug? Feel free to click here: Create an Issue","title":"Getting Started"},{"location":"openthread-mesh/getting-started/#getting-started-with-openthread-mesh-network","text":"This section describes how to quickly run an OpenThread Mesh example without going through the complete toolchain installation. There is no need to build any firmware for running it, as it uses the pre-built firmware of OpenThread CLI example. This example application demonstrates a minimal OpenThread application that exposes the OpenThread configuration and management interfaces via a basic command-line interface.","title":"Getting started with OpenThread Mesh Network"},{"location":"openthread-mesh/getting-started/#hardware-requirements","text":"A minimal OpenThread Mesh network requires at least three nodes. Before starting to work, prepare the following parts: Grove Mesh Kit for nRF52840-MDK * 3 Three AA batteries( Energizer\u00ae Ultimate Lithium\u2122 AA battery is recommended to stay powered longer.) A macOS, Linux or Windows computer.","title":"Hardware Requirements"},{"location":"openthread-mesh/getting-started/#assembling-the-hardware","text":"Place the nRF52840-MDK board onto the Base Dock Attach the four plastic spacers supplied in your box to act as legs for the Base Dock Insert an AA battery into the holder the right way around as marked on the board Tip AA battery is NOT included in the kit. An Energizer\u00ae Ultimate Lithium\u2122 AA battery is recommended to stay powered longer.","title":"Assembling the hardware"},{"location":"openthread-mesh/getting-started/#flashing-the-openthread-cli","text":"Before running the OpenThread CLI example, you need to flash the boards. The pre-built firmware is located in grove-mesh-kit/firmware/openthread/cli : OpenThread CLI firmware Connect one nRF52840-MDK board to your PC using the USB-C cable. A removable drive named DAPLINK will appear. Drag and drop the pre-built cli firmware thread_cli_ftd_uart_nrf52840_mdk.hex into DAPLINK . After flashed, label the board Node#1 so that later you don't confuse the boards. Program the rest two boards by repeating steps as described above. Label them Node#2 and Node#3 Tip You can also program the board using pyOCD . Just follow this tutorial to set up the pyOCD tool.","title":"Flashing the OpenThread CLI"},{"location":"openthread-mesh/getting-started/#running-the-openthread-cli","text":"You can access the OpenThread CLI by using a serial terminal like screen or PuTTY .","title":"Running the OpenThread CLI"},{"location":"openthread-mesh/getting-started/#start-node1","text":"Open a terminal window and run: screen /dev/cu.usbmodem141102 115200 where /dev/cu.usbmodem141102 is the serial port name of Node#1. press Enter on the keyboard to bring up the OpenThread CLI prompt. Set the PAN ID: panid 0x1234 Bring up the IPv6 interface: ifconfig up Start Thread protocol operation: thread start The LED starts blinking GREEN. Wait a few seconds and verify that the device has become a Thread Leader: state leader Done","title":"Start Node#1"},{"location":"openthread-mesh/getting-started/#start-the-rest-nodes","text":"Start the rest nodes by repeating steps as described above. Wait a minute and verify that the devices have become a Thread Router and a child: Node#2: state router Done Node#3: state child Done","title":"Start the rest nodes"},{"location":"openthread-mesh/getting-started/#ping-the-nodes","text":"View IPv6 addresses assigned to Node#2 and Node#3's Thread interface: Node#2: ipaddr fdde:ad00:beef:0:0:ff:fe00:9c00 fdde:ad00:beef:0:5748:44eb:b417:6d79 fe80:0:0:0:80c:e2b5:510b:8543 Done Node#3: ipaddr fdde:ad00:beef:0:0:ff:fe00:8000 fdde:ad00:beef:0:d675:a24e:2320:a5a3 fe80:0:0:0:d00a:c9f8:1e0a:dcb0 Done Ping Node#2 and Node#3 from Node#1(the leader): ping fdde:ad00:beef:0:5748:44eb:b417:6d79 16 bytes from fdde:ad00:beef:0:5748:44eb:b417:6d79: icmp_seq = 1 hlim = 64 time = 10ms ping fdde:ad00:beef:0:d675:a24e:2320:a5a3 16 bytes from fdde:ad00:beef:0:d675:a24e:2320:a5a3: icmp_seq = 2 hlim = 64 time = 39ms","title":"Ping the nodes"},{"location":"openthread-mesh/getting-started/#next-steps","text":"Congratulations! You have built a simple OpenThread Mesh network with three nodes. You may use the CLI to change network parameters, other configurations, and perform other operations. See the OpenThread CLI Reference README.md to explore more. See the Setting Up the Thread SDK section for information on environment setup. Once you set up your Thread development environment, see the Building Running the examples to build the examples on your own machine.","title":"Next Steps"},{"location":"openthread-mesh/getting-started/#create-an-issue","text":"Interested in contributing to this project? Want to report a bug? Feel free to click here: Create an Issue","title":"Create an Issue"},{"location":"openthread-mesh/license/","text":"License The nRF5 SDK for Thread has been released by Nordic Semiconductor . Detailed information is as follows. nRF5 SDK for Thread and Zigbee OpenThread has been released as open source under the BSD 3-Clause license . Detailed license terms are as follows. BSD 3-Clause License The Grove Mesh Kit has been released as open source under the MIT License. Detailed license terms are as follows. MIT License Create an Issue Interested in contributing to this project? Want to report a bug? Feel free to click here: Create an Issue","title":"License"},{"location":"openthread-mesh/license/#license","text":"The nRF5 SDK for Thread has been released by Nordic Semiconductor . Detailed information is as follows. nRF5 SDK for Thread and Zigbee OpenThread has been released as open source under the BSD 3-Clause license . Detailed license terms are as follows. BSD 3-Clause License The Grove Mesh Kit has been released as open source under the MIT License. Detailed license terms are as follows. MIT License","title":"License"},{"location":"openthread-mesh/license/#create-an-issue","text":"Interested in contributing to this project? Want to report a bug? Feel free to click here: Create an Issue","title":"Create an Issue"},{"location":"openthread-mesh/openthread-border-router/","text":"OpenThread Border Router Introduction A Thread Border Router serves as a gateway between the Internet and the Thread network. OpenThread's implementation of a Border Router is called OpenThread Border Router (OTBR). OTBR is a Thread Certified Component on the Raspberry Pi 3B with a Nordic nRF52840 NCP. A Thread Border Router minimally supports the following functions: End-to-end IP connectivity via routing between Thread devices and other external IP networks External Thread Commissioning (for example, a mobile phone) to authenticate and join a Thread device to a Thread network For more technical details, openthread.io is the best place for you. In the following documentation sections, you'll build an OpenThread Border Router with Raspberry Pi 3B and Grove Mesh Kit. Hardware Requirements Raspberry Pi 3B A Grove Mesh Kit for nRF52840-MDK 4 GB (or larger) microSD card and microSD card reader microUSB power supply for Raspberry Pi 3B Set Up Raspberry Pi 3B Download and install Raspbian Download the RASPBIAN STRETCH LITE image to your host and follow the installation guide to install the image on an microSD card. Flash the NCP firmware OTBR runs on an NCP design. The pre-built firmware is located in grove-mesh-kit/firmware/openthread/ncp . Follow these steps to flash the pre-built NCP firmware: Connect one nRF52840-MDK board to your PC using the USB-C cable. Open a file explorer. Confirm that the board has appeared as a removable drive named DAPLINK . This allows you to program the nRF52840 chip. Drag and drop the pre-built NCP firmware thread_ncp_ftd_uart_nrf52840_mdk.hex into DAPLINK . Tip You can also program the board using pyOCD . Just follow this tutorial to set up the pyOCD tool. Set up the Border Router Warning Before you continue, make sure your Raspberry Pi 3B is connected to the internet using Ethernet. The bootstrap script disables the platform's Wi-Fi interface and the setup script requires internet connectivity to download and install wpantund . OTBR communicates with the nRF52840-MDK(serves as NCP) via wpantund . On Raspberry Pi 3B: Clone the OTBR repository: git clone https://github.com/openthread/ot-br-posix Install dependencies: cd ot-br-posix ./script/bootstrap Compile and install OTBR and wpantund . Note that this setup script uses Network Manager to automatically set up the Wi-Fi access point (AP): ./script/setup Attach the NCP device to the Raspberry Pi 3B via USB. Configure the NCP device's serial port in wpantund : Determine the serial port name for the NCP device by checking /dev: ls /dev/tty* Add the serial port name to /etc/wpantund.conf . For example, for a serial port name of ttyACM0 : Config:NCP:SocketPath /dev/ttyACM0 Restart the Border Router. The OTBR service should start on boot. Verify services Verify that all required services are enabled: sudo systemctl status If the setup script above was successful, the RPI3B is in running state and the following services appear in the output: wpantund.service avahi-daemon.service otbr-web.service otbr-agent.service If the RPI3B is in degraded state, some other service has failed to start. Check to see which: sudo systemctl --failed If the failed service is tayga or dnsmasq , it is normal. These services are completely configured as part of the Wi-Fi Access Point Setup . Verify NCP Verify that the NCP is in the correct state: sudo wpanctl status wpanctl is a command line utility provided with wpantund . It is used to communicate with the wireless PAN interface (default is wpan0 ) that wpantund is bound to in the NCP design. If the NCP is successfully running OpenThread and is not a member of a Thread network, the output should be similar to the below: wpan0 = [ NCP:State = offline Daemon:Enabled = true NCP:Version = OPENTHREAD/0.01.00; NRF52840; May 6 2019 15:24:43 Daemon:Version = 0.08.00d (/f19f0b8; May 6 2019 08:15:03) Config:NCP:DriverName = spinel NCP:HardwareAddress = [ 3FC1C13939142925 ] If the NCP:State is uninitialized , troubleshoot with the following: Verify the RPI3B has sufficient power (use the proper external AC adapter). Disconnect and reconnect the NCP device to the RPI3B. Verify that the NCP serial device is present. For example, if the device should be attached to /dev/ttyACM0 : ls /dev/ttyACM* /dev/ttyACM0 Reset the NCP with sudo wpanctl reset . Check the NCP status again with sudo wpanctl status . Use the Web GUI Now, you can use the OpenThread Border Router (OTBR) Web GUI to configure and form, join, or check the status of a Thread network. The Border Router enables Access Point mode and advertises the BorderRouter-AP network default. Connect to the BorderRouter-AP Wi-Fi network and access the Web GUI by visiting the OTBR's local IPv4 address( 10.42.0.1 default) in a mobile browser: Form a Thread network Use the Form menu option to create a new Thread network. After the network forms, confirm by checking the Status menu option or running sudo wpanctl status on the command line of the OTBR: External Thread Commissioning OpenThread Border Router (OTBR) features a Thread Border Agent, which supports external Thread Commissioning. In external Thread Commissioning, a device outside of the Thread network (for example, a mobile phone) commissions new devices onto the network. Prepare the Joiner device You should prepare another nRF52840 board. Flash the board with the OpenThread CLI firmware. The pre-built CLI firmware is located in grove-mesh-kit/firmware/openthread/cli : Connect the nRF52840-MDK board to your PC using the USB-C cable. A removable drive named DAPLINK will appear. Drag and drop the pre-built cli firmware thread_cli_ftd_uart_nrf52840_mdk.hex into DAPLINK . After flashed, label the board Joiner so that later you don't confuse the boards. Open a terminal window and run: screen /dev/cu.usbmodem141102 115200 where /dev/cu.usbmodem141102 is the serial port name of the Joiner. Once the Joiner device is ready, obtain its factory-assigned IEEE EUI-64. Use the eui64 command in the OpenThread CLI: eui64 9019ec5d617d7aab Done Use the Thread Commissioning App External commissioning is supported by the Thread Commissioning App, available for download on the Google Play Store for Android devices. Thread Commissioning App Connect your phone to the Wi-Fi access point BorderRouter-AP , and start the Thread Commissioning App. Select the target Border Router from the available list. The name is the same as the Thread network created by the OTBR Web GUI. If the same Border Router shows up multiple times with different IPv4 and IPv6 addresses, select the one with the static IPv4 address used for the Wi-Fi access point setup ( 10.42.0.1 here). When prompted for a password, enter the passphrase (Commissioner Credential) set by the OTBR Web GUI. Commission the Joiner After connected to the Border Router, the app provides the option to scan a Connect QR Code or enter a Join Passphrase manually. Thread Connect QR Codes are created with the following text string format: v = 1 eui = 9019ec5d617d7aab cc = J01NU5 Where eui is the Joiner device's EUI64 value and cc is the Joiner Credential. Use the following tool to generator your QR Code: Generate jQuery(function(){ jQuery( \"#btn_generate\" ).click(function() { var text = $('#text_usr').val(); if(text != \"\") { jQuery('#output').empty(); jQuery('#output').qrcode({width: 200,height: 200,text: text}); } }); }) In the Thread Commissioning App, scan the Connect QR Code generated above. While the app is waiting, enter the OpenThread CLI on the Joiner device and start the Joiner role with that same Joiner Credential: ifconfig up Done joiner start J01NU5 Done Wait for the DTLS handshake to complete between the Commissioner and Joiner: Join success Join the network On the Joiner device, start the Thread protocol to automatically join the network. thread start Done Check the state after a few moments to confirm. It may initially start as a Child, but within two minutes, it will upgrade to a Router. state router Done Obtain the addresses of the joiner by typing ipaddr: ipaddr fd11:1111:1122:0:0:ff:fe00:cc00 fd11:22:0:0:b37e:fb2f:899a:fe3b fd11:1111:1122:0:54ae:6bc4:6dbf:f0a6 fe80:0:0:0:b0ba:25f2:a1f:d1b1 Done Check the Internet connectivity Test the connectivity between the Joiner device in the Thread network and the Internet by pinging a public IPv4 address. To reach the IPv4 address from the Thread device, a Well-Known Prefix of 64:ff9b::/96 and an IPv4 address of the destination are used. To ping Google\u2019s DNS 8.8.8.8 from the IPv6 address, append a hexadecimal form of the IPv6 to the Well-Known Prefix resulting in: 64:ff9b::808:808 . ping 64 :ff9b::808:808 16 bytes from 64 :ff9b:0:0:0:0:808:808: icmp_seq = 1 hlim = 112 time = 245ms ping 64 :ff9b::808:808 16 bytes from 64 :ff9b:0:0:0:0:808:808: icmp_seq = 2 hlim = 111 time = 230ms ping 64 :ff9b::808:808 16 bytes from 64 :ff9b:0:0:0:0:808:808: icmp_seq = 3 hlim = 110 time = 225ms Congratulations! You've successfully created an OpenThread Border Router, while allowing the Joiner device in the Thread network communicating with the Internet. License Portions of this page are reproduced from work created and shared by Google and used according to terms described in the Creative Commons 3.0 Attribution License . Thread is a registered trademark of the Thread Group, Inc. Create an Issue Interested in contributing to this project? Want to report a bug? Feel free to click here: Create an Issue","title":"OpenThread Border Router"},{"location":"openthread-mesh/openthread-border-router/#openthread-border-router","text":"","title":"OpenThread Border Router"},{"location":"openthread-mesh/openthread-border-router/#introduction","text":"A Thread Border Router serves as a gateway between the Internet and the Thread network. OpenThread's implementation of a Border Router is called OpenThread Border Router (OTBR). OTBR is a Thread Certified Component on the Raspberry Pi 3B with a Nordic nRF52840 NCP. A Thread Border Router minimally supports the following functions: End-to-end IP connectivity via routing between Thread devices and other external IP networks External Thread Commissioning (for example, a mobile phone) to authenticate and join a Thread device to a Thread network For more technical details, openthread.io is the best place for you. In the following documentation sections, you'll build an OpenThread Border Router with Raspberry Pi 3B and Grove Mesh Kit.","title":"Introduction"},{"location":"openthread-mesh/openthread-border-router/#hardware-requirements","text":"Raspberry Pi 3B A Grove Mesh Kit for nRF52840-MDK 4 GB (or larger) microSD card and microSD card reader microUSB power supply for Raspberry Pi 3B","title":"Hardware Requirements"},{"location":"openthread-mesh/openthread-border-router/#set-up-raspberry-pi-3b","text":"","title":"Set Up Raspberry Pi 3B"},{"location":"openthread-mesh/openthread-border-router/#download-and-install-raspbian","text":"Download the RASPBIAN STRETCH LITE image to your host and follow the installation guide to install the image on an microSD card.","title":"Download and install Raspbian"},{"location":"openthread-mesh/openthread-border-router/#flash-the-ncp-firmware","text":"OTBR runs on an NCP design. The pre-built firmware is located in grove-mesh-kit/firmware/openthread/ncp . Follow these steps to flash the pre-built NCP firmware: Connect one nRF52840-MDK board to your PC using the USB-C cable. Open a file explorer. Confirm that the board has appeared as a removable drive named DAPLINK . This allows you to program the nRF52840 chip. Drag and drop the pre-built NCP firmware thread_ncp_ftd_uart_nrf52840_mdk.hex into DAPLINK . Tip You can also program the board using pyOCD . Just follow this tutorial to set up the pyOCD tool.","title":"Flash the NCP firmware"},{"location":"openthread-mesh/openthread-border-router/#set-up-the-border-router","text":"Warning Before you continue, make sure your Raspberry Pi 3B is connected to the internet using Ethernet. The bootstrap script disables the platform's Wi-Fi interface and the setup script requires internet connectivity to download and install wpantund . OTBR communicates with the nRF52840-MDK(serves as NCP) via wpantund . On Raspberry Pi 3B: Clone the OTBR repository: git clone https://github.com/openthread/ot-br-posix Install dependencies: cd ot-br-posix ./script/bootstrap Compile and install OTBR and wpantund . Note that this setup script uses Network Manager to automatically set up the Wi-Fi access point (AP): ./script/setup Attach the NCP device to the Raspberry Pi 3B via USB. Configure the NCP device's serial port in wpantund : Determine the serial port name for the NCP device by checking /dev: ls /dev/tty* Add the serial port name to /etc/wpantund.conf . For example, for a serial port name of ttyACM0 : Config:NCP:SocketPath /dev/ttyACM0 Restart the Border Router. The OTBR service should start on boot.","title":"Set up the Border Router"},{"location":"openthread-mesh/openthread-border-router/#verify-services","text":"Verify that all required services are enabled: sudo systemctl status If the setup script above was successful, the RPI3B is in running state and the following services appear in the output: wpantund.service avahi-daemon.service otbr-web.service otbr-agent.service If the RPI3B is in degraded state, some other service has failed to start. Check to see which: sudo systemctl --failed If the failed service is tayga or dnsmasq , it is normal. These services are completely configured as part of the Wi-Fi Access Point Setup .","title":"Verify services"},{"location":"openthread-mesh/openthread-border-router/#verify-ncp","text":"Verify that the NCP is in the correct state: sudo wpanctl status wpanctl is a command line utility provided with wpantund . It is used to communicate with the wireless PAN interface (default is wpan0 ) that wpantund is bound to in the NCP design. If the NCP is successfully running OpenThread and is not a member of a Thread network, the output should be similar to the below: wpan0 = [ NCP:State = offline Daemon:Enabled = true NCP:Version = OPENTHREAD/0.01.00; NRF52840; May 6 2019 15:24:43 Daemon:Version = 0.08.00d (/f19f0b8; May 6 2019 08:15:03) Config:NCP:DriverName = spinel NCP:HardwareAddress = [ 3FC1C13939142925 ] If the NCP:State is uninitialized , troubleshoot with the following: Verify the RPI3B has sufficient power (use the proper external AC adapter). Disconnect and reconnect the NCP device to the RPI3B. Verify that the NCP serial device is present. For example, if the device should be attached to /dev/ttyACM0 : ls /dev/ttyACM* /dev/ttyACM0 Reset the NCP with sudo wpanctl reset . Check the NCP status again with sudo wpanctl status .","title":"Verify NCP"},{"location":"openthread-mesh/openthread-border-router/#use-the-web-gui","text":"Now, you can use the OpenThread Border Router (OTBR) Web GUI to configure and form, join, or check the status of a Thread network. The Border Router enables Access Point mode and advertises the BorderRouter-AP network default. Connect to the BorderRouter-AP Wi-Fi network and access the Web GUI by visiting the OTBR's local IPv4 address( 10.42.0.1 default) in a mobile browser:","title":"Use the Web GUI"},{"location":"openthread-mesh/openthread-border-router/#form-a-thread-network","text":"Use the Form menu option to create a new Thread network. After the network forms, confirm by checking the Status menu option or running sudo wpanctl status on the command line of the OTBR:","title":"Form a Thread network"},{"location":"openthread-mesh/openthread-border-router/#external-thread-commissioning","text":"OpenThread Border Router (OTBR) features a Thread Border Agent, which supports external Thread Commissioning. In external Thread Commissioning, a device outside of the Thread network (for example, a mobile phone) commissions new devices onto the network.","title":"External Thread Commissioning"},{"location":"openthread-mesh/openthread-border-router/#prepare-the-joiner-device","text":"You should prepare another nRF52840 board. Flash the board with the OpenThread CLI firmware. The pre-built CLI firmware is located in grove-mesh-kit/firmware/openthread/cli : Connect the nRF52840-MDK board to your PC using the USB-C cable. A removable drive named DAPLINK will appear. Drag and drop the pre-built cli firmware thread_cli_ftd_uart_nrf52840_mdk.hex into DAPLINK . After flashed, label the board Joiner so that later you don't confuse the boards. Open a terminal window and run: screen /dev/cu.usbmodem141102 115200 where /dev/cu.usbmodem141102 is the serial port name of the Joiner. Once the Joiner device is ready, obtain its factory-assigned IEEE EUI-64. Use the eui64 command in the OpenThread CLI: eui64 9019ec5d617d7aab Done","title":"Prepare the Joiner device"},{"location":"openthread-mesh/openthread-border-router/#use-the-thread-commissioning-app","text":"External commissioning is supported by the Thread Commissioning App, available for download on the Google Play Store for Android devices. Thread Commissioning App Connect your phone to the Wi-Fi access point BorderRouter-AP , and start the Thread Commissioning App. Select the target Border Router from the available list. The name is the same as the Thread network created by the OTBR Web GUI. If the same Border Router shows up multiple times with different IPv4 and IPv6 addresses, select the one with the static IPv4 address used for the Wi-Fi access point setup ( 10.42.0.1 here). When prompted for a password, enter the passphrase (Commissioner Credential) set by the OTBR Web GUI.","title":"Use the Thread Commissioning App"},{"location":"openthread-mesh/openthread-border-router/#commission-the-joiner","text":"After connected to the Border Router, the app provides the option to scan a Connect QR Code or enter a Join Passphrase manually. Thread Connect QR Codes are created with the following text string format: v = 1 eui = 9019ec5d617d7aab cc = J01NU5 Where eui is the Joiner device's EUI64 value and cc is the Joiner Credential. Use the following tool to generator your QR Code: Generate jQuery(function(){ jQuery( \"#btn_generate\" ).click(function() { var text = $('#text_usr').val(); if(text != \"\") { jQuery('#output').empty(); jQuery('#output').qrcode({width: 200,height: 200,text: text}); } }); }) In the Thread Commissioning App, scan the Connect QR Code generated above. While the app is waiting, enter the OpenThread CLI on the Joiner device and start the Joiner role with that same Joiner Credential: ifconfig up Done joiner start J01NU5 Done Wait for the DTLS handshake to complete between the Commissioner and Joiner: Join success","title":"Commission the Joiner"},{"location":"openthread-mesh/openthread-border-router/#join-the-network","text":"On the Joiner device, start the Thread protocol to automatically join the network. thread start Done Check the state after a few moments to confirm. It may initially start as a Child, but within two minutes, it will upgrade to a Router. state router Done Obtain the addresses of the joiner by typing ipaddr: ipaddr fd11:1111:1122:0:0:ff:fe00:cc00 fd11:22:0:0:b37e:fb2f:899a:fe3b fd11:1111:1122:0:54ae:6bc4:6dbf:f0a6 fe80:0:0:0:b0ba:25f2:a1f:d1b1 Done","title":"Join the network"},{"location":"openthread-mesh/openthread-border-router/#check-the-internet-connectivity","text":"Test the connectivity between the Joiner device in the Thread network and the Internet by pinging a public IPv4 address. To reach the IPv4 address from the Thread device, a Well-Known Prefix of 64:ff9b::/96 and an IPv4 address of the destination are used. To ping Google\u2019s DNS 8.8.8.8 from the IPv6 address, append a hexadecimal form of the IPv6 to the Well-Known Prefix resulting in: 64:ff9b::808:808 . ping 64 :ff9b::808:808 16 bytes from 64 :ff9b:0:0:0:0:808:808: icmp_seq = 1 hlim = 112 time = 245ms ping 64 :ff9b::808:808 16 bytes from 64 :ff9b:0:0:0:0:808:808: icmp_seq = 2 hlim = 111 time = 230ms ping 64 :ff9b::808:808 16 bytes from 64 :ff9b:0:0:0:0:808:808: icmp_seq = 3 hlim = 110 time = 225ms","title":"Check the Internet connectivity"},{"location":"openthread-mesh/openthread-border-router/#congratulations","text":"You've successfully created an OpenThread Border Router, while allowing the Joiner device in the Thread network communicating with the Internet.","title":"Congratulations!"},{"location":"openthread-mesh/openthread-border-router/#license","text":"Portions of this page are reproduced from work created and shared by Google and used according to terms described in the Creative Commons 3.0 Attribution License . Thread is a registered trademark of the Thread Group, Inc.","title":"License"},{"location":"openthread-mesh/openthread-border-router/#create-an-issue","text":"Interested in contributing to this project? Want to report a bug? Feel free to click here: Create an Issue","title":"Create an Issue"},{"location":"openthread-mesh/setting-up-the-thread-sdk/","text":"Setting Up the OpenThread Mesh SDK This section describes how to set up the nRF5 SDK for Thread development environment on your host operating system. Set up the toolchain To build the nRF5 SDK for Thread examples, GNU ARM Embedded Toolchain is required. Follow one of the following guides for your host operating system: macOS Windows Linux macOS GNU make is bundled with Xcode tools. Verify by running: make --v Download and install the GNU ARM Embedded Toolchain . The 7-2018-q2-update version is required. If you already have another version of arm-none-eabi installed, ensure to modify your OS PATH environment variable. # in ~/.bash_profile, add the following script export PATH = path to install directory /gcc-arm-none-eabi-7-2018-q2-update/bin: ${ PATH } Type the following in your terminal to verify if the path is set correctly: arm-none-eabi-gcc --version Download the nRF5x-Command-Line-Tools-OSX , then extract the .tar archive anywhere on your filesystem. Ensure the extracted directory is added to your OS PATH environment variable. # in ~/.bash_profile, add the following script export PATH = the path to the extracted directory : ${ PATH } Type the following in your terminal to verify if mergehex works: mergehex --version Install the latest stable version of pyOCD via pip as follows: pip install -U pyocd Type the following in your terminal to verify if pyocd works: pyocd --version Windows On Windows the easiest way to install the dependencies is to use the MSYS2 . You can do so by performing the following steps: Download and run the installer - \"x86_64\" for 64-bit, \"i686\" for 32-bit Windows. Download Start MSYS2. Update the package database and core system packages with: pacman -Syu If needed, close MSYS2, run it again from Start menu. Update the rest with: pacman -Su Install dependencies: pacman -S git make python2 Download and install the GNU ARM Embedded Toolchain . The 7-2018-q2-update version is required. Run the installer and follow the given instructions. Upon completion, check the Add path to environment variable option. Then verify if the compiler works: arm-none-eabi-gcc --version Download the nRF5x-Command-Line-Tools for Win32 . Run the installer and follow the given instructions. Then verify if mergehex works: mergehex --version Install the latest stable version of pyOCD via pip as follows: pip install -U pyocd Type the following in your terminal to verify if pyocd works: pyocd --version Linux This section describes how to set up the development environment on Ubuntu. The steps should be similar for other Linux distributions. Ensure your host system is up to date before proceeding. sudo apt-get update sudo apt-get upgrade Install the following packages using your system\u2019s package manager. sudo apt-get install build-essential checkinstall Download and install the GNU ARM Embedded Toolchain . The 7-2018-q2-update version is required. If you already have another version of arm-none-eabi installed, ensure to modify your OS PATH environment variable. # in ~/.bash_profile, add the following script export PATH = path to install directory /gcc-arm-none-eabi-7-2018-q2-update/bin: ${ PATH } Type the following in your terminal to verify if the path is set correctly: arm-none-eabi-gcc --version Download the nRF5x-Command-Line-Tools-Linux-xxx , then extract the .tar archive anywhere on your filesystem. Ensure the extracted directory is added to your OS PATH environment variable. # in ~/.bash_profile, add the following script export PATH = the path to the extracted directory : ${ PATH } Type the following in your terminal to verify if mergehex works: mergehex --version Install the latest stable version of pyOCD via pip as follows: pip install -U pyocd Type the following in your terminal to verify if pyocd works: pyocd --version Clone the repository Clone the grove-mesh-kit repository from GitHub: git clone --recursive https://github.com/makerdiary/grove-mesh-kit Where adding --recursive will clone all the necessary dependencies. Or if you have already cloned the project, you may update the submodule: git submodule update --init Install the nRF5 SDK for Thread Download the SDK file nRF5 SDK for Thread and Zigbee V3.0.0 from www.nordicsemi.com . Download Extract the zip file to the grove-mesh-kit repository. This should give you the following folder structure: ./grove-mesh-kit/ \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 README.md \u251c\u2500\u2500 config \u251c\u2500\u2500 deps \u2502 \u2514\u2500\u2500 openthread \u251c\u2500\u2500 docs \u251c\u2500\u2500 examples \u251c\u2500\u2500 firmware \u251c\u2500\u2500 mkdocs.yml \u2514\u2500\u2500 nrf_sdks \u251c\u2500\u2500 README.md \u251c\u2500\u2500 nRF5-SDK-for-Mesh \u251c\u2500\u2500 nRF5SDKforThreadandZigbeev300d310e71 \u2514\u2500\u2500 nRF5_SDK_v15.2.0_9412b96 To use the Thread SDK you first need to set the toolchain path in makefile.windows or makefile.posix depending on platform you are using. That is, the .posix should be edited if your are working on either Linux or macOS. These files are located in: Thread SDK /components/toolchain/gcc Open the file in a text editor ( Sublime is recommended), and make sure that the GNU_INSTALL_ROOT variable is pointing to your GNU Arm Embedded Toolchain install directory. GNU_INSTALL_ROOT ? = $( HOME ) /gcc-arm-none-eabi/gcc-arm-none-eabi-7-2018-q2-update/bin/ GNU_VERSION ? = 7 .3.1 GNU_PREFIX ? = arm-none-eabi Next Steps Congratulations! Now you can try to build and run the mesh examples. Head to Building Running the examples section for more details. Create an Issue Interested in contributing to this project? Want to report a bug? Feel free to click here: Create an Issue","title":"Setting Up the Thread SDK"},{"location":"openthread-mesh/setting-up-the-thread-sdk/#setting-up-the-openthread-mesh-sdk","text":"This section describes how to set up the nRF5 SDK for Thread development environment on your host operating system.","title":"Setting Up the OpenThread Mesh SDK"},{"location":"openthread-mesh/setting-up-the-thread-sdk/#set-up-the-toolchain","text":"To build the nRF5 SDK for Thread examples, GNU ARM Embedded Toolchain is required. Follow one of the following guides for your host operating system: macOS Windows Linux","title":"Set up the toolchain"},{"location":"openthread-mesh/setting-up-the-thread-sdk/#macos","text":"GNU make is bundled with Xcode tools. Verify by running: make --v Download and install the GNU ARM Embedded Toolchain . The 7-2018-q2-update version is required. If you already have another version of arm-none-eabi installed, ensure to modify your OS PATH environment variable. # in ~/.bash_profile, add the following script export PATH = path to install directory /gcc-arm-none-eabi-7-2018-q2-update/bin: ${ PATH } Type the following in your terminal to verify if the path is set correctly: arm-none-eabi-gcc --version Download the nRF5x-Command-Line-Tools-OSX , then extract the .tar archive anywhere on your filesystem. Ensure the extracted directory is added to your OS PATH environment variable. # in ~/.bash_profile, add the following script export PATH = the path to the extracted directory : ${ PATH } Type the following in your terminal to verify if mergehex works: mergehex --version Install the latest stable version of pyOCD via pip as follows: pip install -U pyocd Type the following in your terminal to verify if pyocd works: pyocd --version","title":"macOS"},{"location":"openthread-mesh/setting-up-the-thread-sdk/#windows","text":"On Windows the easiest way to install the dependencies is to use the MSYS2 . You can do so by performing the following steps: Download and run the installer - \"x86_64\" for 64-bit, \"i686\" for 32-bit Windows. Download Start MSYS2. Update the package database and core system packages with: pacman -Syu If needed, close MSYS2, run it again from Start menu. Update the rest with: pacman -Su Install dependencies: pacman -S git make python2 Download and install the GNU ARM Embedded Toolchain . The 7-2018-q2-update version is required. Run the installer and follow the given instructions. Upon completion, check the Add path to environment variable option. Then verify if the compiler works: arm-none-eabi-gcc --version Download the nRF5x-Command-Line-Tools for Win32 . Run the installer and follow the given instructions. Then verify if mergehex works: mergehex --version Install the latest stable version of pyOCD via pip as follows: pip install -U pyocd Type the following in your terminal to verify if pyocd works: pyocd --version","title":"Windows"},{"location":"openthread-mesh/setting-up-the-thread-sdk/#linux","text":"This section describes how to set up the development environment on Ubuntu. The steps should be similar for other Linux distributions. Ensure your host system is up to date before proceeding. sudo apt-get update sudo apt-get upgrade Install the following packages using your system\u2019s package manager. sudo apt-get install build-essential checkinstall Download and install the GNU ARM Embedded Toolchain . The 7-2018-q2-update version is required. If you already have another version of arm-none-eabi installed, ensure to modify your OS PATH environment variable. # in ~/.bash_profile, add the following script export PATH = path to install directory /gcc-arm-none-eabi-7-2018-q2-update/bin: ${ PATH } Type the following in your terminal to verify if the path is set correctly: arm-none-eabi-gcc --version Download the nRF5x-Command-Line-Tools-Linux-xxx , then extract the .tar archive anywhere on your filesystem. Ensure the extracted directory is added to your OS PATH environment variable. # in ~/.bash_profile, add the following script export PATH = the path to the extracted directory : ${ PATH } Type the following in your terminal to verify if mergehex works: mergehex --version Install the latest stable version of pyOCD via pip as follows: pip install -U pyocd Type the following in your terminal to verify if pyocd works: pyocd --version","title":"Linux"},{"location":"openthread-mesh/setting-up-the-thread-sdk/#clone-the-repository","text":"Clone the grove-mesh-kit repository from GitHub: git clone --recursive https://github.com/makerdiary/grove-mesh-kit Where adding --recursive will clone all the necessary dependencies. Or if you have already cloned the project, you may update the submodule: git submodule update --init","title":"Clone the repository"},{"location":"openthread-mesh/setting-up-the-thread-sdk/#install-the-nrf5-sdk-for-thread","text":"Download the SDK file nRF5 SDK for Thread and Zigbee V3.0.0 from www.nordicsemi.com . Download Extract the zip file to the grove-mesh-kit repository. This should give you the following folder structure: ./grove-mesh-kit/ \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 README.md \u251c\u2500\u2500 config \u251c\u2500\u2500 deps \u2502 \u2514\u2500\u2500 openthread \u251c\u2500\u2500 docs \u251c\u2500\u2500 examples \u251c\u2500\u2500 firmware \u251c\u2500\u2500 mkdocs.yml \u2514\u2500\u2500 nrf_sdks \u251c\u2500\u2500 README.md \u251c\u2500\u2500 nRF5-SDK-for-Mesh \u251c\u2500\u2500 nRF5SDKforThreadandZigbeev300d310e71 \u2514\u2500\u2500 nRF5_SDK_v15.2.0_9412b96 To use the Thread SDK you first need to set the toolchain path in makefile.windows or makefile.posix depending on platform you are using. That is, the .posix should be edited if your are working on either Linux or macOS. These files are located in: Thread SDK /components/toolchain/gcc Open the file in a text editor ( Sublime is recommended), and make sure that the GNU_INSTALL_ROOT variable is pointing to your GNU Arm Embedded Toolchain install directory. GNU_INSTALL_ROOT ? = $( HOME ) /gcc-arm-none-eabi/gcc-arm-none-eabi-7-2018-q2-update/bin/ GNU_VERSION ? = 7 .3.1 GNU_PREFIX ? = arm-none-eabi","title":"Install the nRF5 SDK for Thread"},{"location":"openthread-mesh/setting-up-the-thread-sdk/#next-steps","text":"Congratulations! Now you can try to build and run the mesh examples. Head to Building Running the examples section for more details.","title":"Next Steps"},{"location":"openthread-mesh/setting-up-the-thread-sdk/#create-an-issue","text":"Interested in contributing to this project? Want to report a bug? Feel free to click here: Create an Issue","title":"Create an Issue"},{"location":"openthread-mesh/thread-network-sniffer/","text":"Build a Thread Network Sniffer Overivew During development, you may need to check what kind of data is wirelessly transmitted over the Thread network. With Pyspinel and Wireshark, you can set up a sniffer which allows to dynamically monitor the IEEE 802.15.4 wireless traffic. The Pyspinel sniffer tool connects to a Thread NCP device and converts it into a promiscuous packet sniffer, generating a pcap (packet capture) stream to be saved or piped directly into Wireshark. Wireshark is an open-source tool that can decode network protocols in the Thread stack, such as IEEE 802.15.4, 6LoWPAN, IPv6, MLE (Mesh Link Establishment), UDP, and CoAP. This section describes how to set up a Thread Sniffer, which can help you to efficiently analyze Thread network traffic. Requirements macOS or Ubuntu machine A Grove Mesh Kit for nRF52840-MDK Python 2.7 or Python 3 Wireshark 2.4.1 or newer Installation Set up the sniffer environment Clone and install Pyspinel and dependencies: git clone https://github.com/openthread/pyspinel cd pyspinel pip install --user future pyserial ipaddress Install Wireshark On MacOS, go to the Wireshark Download page and install the current stable release of Wireshark. On Ubuntu Linux, you can run the following commands: $ sudo add-apt-repository ppa:wireshark-dev/stable $ sudo apt-get update $ sudo apt-get install wireshark Flash the NCP Radio firmware The pre-built firmware is located in grove-mesh-kit/firmware/openthread/ncp . Follow these steps to flash the pre-built NCP Radio firmware: Connect one nRF52840-MDK board to your PC using the USB-C cable. Open a file explorer. Confirm that the board has appeared as a removable drive named DAPLINK . This allows you to program the nRF52840 chip. Drag and drop the pre-built NCP Radio firmware thread_ncp_radio_uart_nrf52840_mdk.hex into DAPLINK . Tip You can also program the board using pyOCD . Just follow this tutorial to set up the pyOCD tool. Thread network properties Before continuing, get the following properties for the Thread network you wish to sniff. You'll need them for Wireshark configuration and running the Pyspinel sniffer. Mesh Local Prefix To get the Mesh Local Prefix from a device in the target Thread network: Using the OpenThread CLI: dataset active Active Timestamp: 0 Channel: 15 Channel Mask: 07fff800 Ext PAN ID: 1111111122222222 Mesh Local Prefix: fd11:1111:1122:0/64 Master Key: 00112233445566778899aabbccddeeff Network Name: OpenThreadDemo PAN ID: 0x1234 PSKc: 61e1206d2c2b46e079eb775f41fc7219 Security Policy: 672 , onrcb Done Using wpanctl with an NCP: $ sudo wpanctl getprop IPv6:MeshLocalPrefix IPv6:MeshLocalPrefix = fd11:1111:1122::/64 Using the OTBR Web GUI, select Status . The Mesh Local Prefix is listed as IPv6:MeshLocalPrefix similar to wpanctl . Channel To get the Channel from a device in the target Thread network: Using the OpenThread CLI: channel 15 Done Using wpanctl with an NCP: $ sudo wpanctl getprop NCP:Channel NCP:Channel = 15 Using the OTBR Web GUI, select Status . The Channel is listed as NCP:Channel similar to wpanctl . Master Key The Thread network Master Key is used by Wireshark to decrypt packets after capture. To get the Master Key from a device in the target Thread network: Using the OpenThread CLI: masterkey 00112233445566778899aabbccddeeff Done Using wpanctl with an NCP: $ sudo wpanctl getprop Network:Key Network:Key = [ 00112233445566778899AABBCCDDEEFF ] Note The Thread network Master Key is not available in the OTBR Web GUI. Wireshark configuration - protocols Wireshark must be configured to properly show Thread packets. Select Preferences... in Wireshark and expand the Protocols section. 6LoWPAN Select 6LoWPAN from the list of protocols and verify or change the following settings: Uncheck Derive ID according to RFC 4944 . Update Context 0 with the Mesh Local Prefix for the target Thread network. Wireshark uses context configurations to parse the compressed IPv6 address and display the IPv6 source and destination addresses correctly. CoAP Select CoAP from the list of protocols and set CoAP UDP Port to 61631 . This ensures TMF messages (like address solicit) are displayed. IEEE 802.15.4 Select IEEE 802.15.4 from the list of protocols and verify or change the following settings: Set 802.15.4 Ethertype (in hex) to 0x809a . Set the Security Suite (802.15.4-2003) to AES-128 Encryption, 32-bit Integrity Protection . Click the Edit... button next to Decryption Keys , which is where you add the Thread network Master Key for packet decryption. a. Click + to add a Decryption key . b. Enter the Thread network Master Key into the Decryption key column. c Enter 1 as the Decryption key index . d. Select Thread hash from the Key hash column listbox. e. Click OK to save the decryption key. Thread Select Thread from the list of protocols and verify or change the following settings: Enter 00000000 for the Thread sequence counter . Uncheck Use PAN ID as first two octets of master key . Check Automatically acquire Thread sequence counter . Click the OK button to save any protocol changes. Note Some Thread traffic might be analyzed as the ZigBee protocol. To correctly display these two protocols, edit the enabled protocols in Wireshark: In Wireshark, go to Analyze Enabled Protocols . Uncheck the following protocols: LwMesh ZigBee ZigBee Green Power Wireshark configuration - RSSI To display RSSI in Wireshark: Go to Preferences Protocols IEEE 802.15.4 . Check TI CC24xx FCS format . Click OK to save and return to the Preferences menu. From Preferences , select Appearance Columns . Add a new entry: Title: RSSI Type: Custom Fields: wpan.rssi Run the sniffer Make sure to use the specific device path for your NCP and the channel for the Thread network you are attempting to sniff. Change to the pyspinel directory and start Wireshark with the following command: sudo python ./sniffer.py -c 15 -u /dev/cu.usbmodem142102 --crc --rssi -b 115200 | wireshark -k -i - The parameters stand for the following: -c : Thread Channel -u : The NCP device path \u2013crc : Disable the wrong FCS warning resulting from the fact that Nordic radio replaces one byte of CRC with LQI after a packet is received and verified. --rssi : Ensure the RSSI is included in the pcap output. -b : Baud rate You should now be able to see the packets and related protocols for this configuration in Wireshark: Reference For more information on how to use Pyspinel and Wireshark, see the following: Spinel sniffer reference wireshark.org openthread.io - Packet sniffing with Pyspinel License Portions of this page are reproduced from work created and shared by Google and used according to terms described in the Creative Commons 3.0 Attribution License . Thread is a registered trademark of the Thread Group, Inc. Create an Issue Interested in contributing to this project? Want to report a bug? Feel free to click here: Create an Issue","title":"Thread Network Sniffer"},{"location":"openthread-mesh/thread-network-sniffer/#build-a-thread-network-sniffer","text":"","title":"Build a Thread Network Sniffer"},{"location":"openthread-mesh/thread-network-sniffer/#overivew","text":"During development, you may need to check what kind of data is wirelessly transmitted over the Thread network. With Pyspinel and Wireshark, you can set up a sniffer which allows to dynamically monitor the IEEE 802.15.4 wireless traffic. The Pyspinel sniffer tool connects to a Thread NCP device and converts it into a promiscuous packet sniffer, generating a pcap (packet capture) stream to be saved or piped directly into Wireshark. Wireshark is an open-source tool that can decode network protocols in the Thread stack, such as IEEE 802.15.4, 6LoWPAN, IPv6, MLE (Mesh Link Establishment), UDP, and CoAP. This section describes how to set up a Thread Sniffer, which can help you to efficiently analyze Thread network traffic.","title":"Overivew"},{"location":"openthread-mesh/thread-network-sniffer/#requirements","text":"macOS or Ubuntu machine A Grove Mesh Kit for nRF52840-MDK Python 2.7 or Python 3 Wireshark 2.4.1 or newer","title":"Requirements"},{"location":"openthread-mesh/thread-network-sniffer/#installation","text":"","title":"Installation"},{"location":"openthread-mesh/thread-network-sniffer/#set-up-the-sniffer-environment","text":"Clone and install Pyspinel and dependencies: git clone https://github.com/openthread/pyspinel cd pyspinel pip install --user future pyserial ipaddress","title":"Set up the sniffer environment"},{"location":"openthread-mesh/thread-network-sniffer/#install-wireshark","text":"On MacOS, go to the Wireshark Download page and install the current stable release of Wireshark. On Ubuntu Linux, you can run the following commands: $ sudo add-apt-repository ppa:wireshark-dev/stable $ sudo apt-get update $ sudo apt-get install wireshark","title":"Install Wireshark"},{"location":"openthread-mesh/thread-network-sniffer/#flash-the-ncp-radio-firmware","text":"The pre-built firmware is located in grove-mesh-kit/firmware/openthread/ncp . Follow these steps to flash the pre-built NCP Radio firmware: Connect one nRF52840-MDK board to your PC using the USB-C cable. Open a file explorer. Confirm that the board has appeared as a removable drive named DAPLINK . This allows you to program the nRF52840 chip. Drag and drop the pre-built NCP Radio firmware thread_ncp_radio_uart_nrf52840_mdk.hex into DAPLINK . Tip You can also program the board using pyOCD . Just follow this tutorial to set up the pyOCD tool.","title":"Flash the NCP Radio firmware"},{"location":"openthread-mesh/thread-network-sniffer/#thread-network-properties","text":"Before continuing, get the following properties for the Thread network you wish to sniff. You'll need them for Wireshark configuration and running the Pyspinel sniffer.","title":"Thread network properties"},{"location":"openthread-mesh/thread-network-sniffer/#mesh-local-prefix","text":"To get the Mesh Local Prefix from a device in the target Thread network: Using the OpenThread CLI: dataset active Active Timestamp: 0 Channel: 15 Channel Mask: 07fff800 Ext PAN ID: 1111111122222222 Mesh Local Prefix: fd11:1111:1122:0/64 Master Key: 00112233445566778899aabbccddeeff Network Name: OpenThreadDemo PAN ID: 0x1234 PSKc: 61e1206d2c2b46e079eb775f41fc7219 Security Policy: 672 , onrcb Done Using wpanctl with an NCP: $ sudo wpanctl getprop IPv6:MeshLocalPrefix IPv6:MeshLocalPrefix = fd11:1111:1122::/64 Using the OTBR Web GUI, select Status . The Mesh Local Prefix is listed as IPv6:MeshLocalPrefix similar to wpanctl .","title":"Mesh Local Prefix"},{"location":"openthread-mesh/thread-network-sniffer/#channel","text":"To get the Channel from a device in the target Thread network: Using the OpenThread CLI: channel 15 Done Using wpanctl with an NCP: $ sudo wpanctl getprop NCP:Channel NCP:Channel = 15 Using the OTBR Web GUI, select Status . The Channel is listed as NCP:Channel similar to wpanctl .","title":"Channel"},{"location":"openthread-mesh/thread-network-sniffer/#master-key","text":"The Thread network Master Key is used by Wireshark to decrypt packets after capture. To get the Master Key from a device in the target Thread network: Using the OpenThread CLI: masterkey 00112233445566778899aabbccddeeff Done Using wpanctl with an NCP: $ sudo wpanctl getprop Network:Key Network:Key = [ 00112233445566778899AABBCCDDEEFF ] Note The Thread network Master Key is not available in the OTBR Web GUI.","title":"Master Key"},{"location":"openthread-mesh/thread-network-sniffer/#wireshark-configuration-protocols","text":"Wireshark must be configured to properly show Thread packets. Select Preferences... in Wireshark and expand the Protocols section.","title":"Wireshark configuration - protocols"},{"location":"openthread-mesh/thread-network-sniffer/#6lowpan","text":"Select 6LoWPAN from the list of protocols and verify or change the following settings: Uncheck Derive ID according to RFC 4944 . Update Context 0 with the Mesh Local Prefix for the target Thread network. Wireshark uses context configurations to parse the compressed IPv6 address and display the IPv6 source and destination addresses correctly.","title":"6LoWPAN"},{"location":"openthread-mesh/thread-network-sniffer/#coap","text":"Select CoAP from the list of protocols and set CoAP UDP Port to 61631 . This ensures TMF messages (like address solicit) are displayed.","title":"CoAP"},{"location":"openthread-mesh/thread-network-sniffer/#ieee-802154","text":"Select IEEE 802.15.4 from the list of protocols and verify or change the following settings: Set 802.15.4 Ethertype (in hex) to 0x809a . Set the Security Suite (802.15.4-2003) to AES-128 Encryption, 32-bit Integrity Protection . Click the Edit... button next to Decryption Keys , which is where you add the Thread network Master Key for packet decryption. a. Click + to add a Decryption key . b. Enter the Thread network Master Key into the Decryption key column. c Enter 1 as the Decryption key index . d. Select Thread hash from the Key hash column listbox. e. Click OK to save the decryption key.","title":"IEEE 802.15.4"},{"location":"openthread-mesh/thread-network-sniffer/#thread","text":"Select Thread from the list of protocols and verify or change the following settings: Enter 00000000 for the Thread sequence counter . Uncheck Use PAN ID as first two octets of master key . Check Automatically acquire Thread sequence counter . Click the OK button to save any protocol changes. Note Some Thread traffic might be analyzed as the ZigBee protocol. To correctly display these two protocols, edit the enabled protocols in Wireshark: In Wireshark, go to Analyze Enabled Protocols . Uncheck the following protocols: LwMesh ZigBee ZigBee Green Power","title":"Thread"},{"location":"openthread-mesh/thread-network-sniffer/#wireshark-configuration-rssi","text":"To display RSSI in Wireshark: Go to Preferences Protocols IEEE 802.15.4 . Check TI CC24xx FCS format . Click OK to save and return to the Preferences menu. From Preferences , select Appearance Columns . Add a new entry: Title: RSSI Type: Custom Fields: wpan.rssi","title":"Wireshark configuration - RSSI"},{"location":"openthread-mesh/thread-network-sniffer/#run-the-sniffer","text":"Make sure to use the specific device path for your NCP and the channel for the Thread network you are attempting to sniff. Change to the pyspinel directory and start Wireshark with the following command: sudo python ./sniffer.py -c 15 -u /dev/cu.usbmodem142102 --crc --rssi -b 115200 | wireshark -k -i - The parameters stand for the following: -c : Thread Channel -u : The NCP device path \u2013crc : Disable the wrong FCS warning resulting from the fact that Nordic radio replaces one byte of CRC with LQI after a packet is received and verified. --rssi : Ensure the RSSI is included in the pcap output. -b : Baud rate You should now be able to see the packets and related protocols for this configuration in Wireshark:","title":"Run the sniffer"},{"location":"openthread-mesh/thread-network-sniffer/#reference","text":"For more information on how to use Pyspinel and Wireshark, see the following: Spinel sniffer reference wireshark.org openthread.io - Packet sniffing with Pyspinel","title":"Reference"},{"location":"openthread-mesh/thread-network-sniffer/#license","text":"Portions of this page are reproduced from work created and shared by Google and used according to terms described in the Creative Commons 3.0 Attribution License . Thread is a registered trademark of the Thread Group, Inc.","title":"License"},{"location":"openthread-mesh/thread-network-sniffer/#create-an-issue","text":"Interested in contributing to this project? Want to report a bug? Feel free to click here: Create an Issue","title":"Create an Issue"},{"location":"openthread-mesh/thread-topology-monitor/","text":"Thread Topology Monitor This section describes how to set up the nRF Thread Topology Monitor to visualize the current network topology. Introduction nRF Thread Topology Monitor is a cross-platform tool that enables developers to visualize Thread mesh network topology in real time. The tool is supported on Windows and Linux with separate downloads for each platform. It requires a serial connection to an nRF52840 board with Nordic\u2019s Thread solution. nRF Thread Topology Monitor uses diagnostic mechanisms of the Thread protocol to retrieve information about routing tables of each Thread Router currently attached to the network. The tool also allows to identify a particular device in the network using LEDs by interacting with the Thread BSP solution. You may assign a custom label to a Thread node and store it in persistent memory on the PC side, which helps to track topology changes. Installation Navigate to nRF Thread Topology Monitor page and download one of the following packages: Windows: nRF_TTM-win32-x64_v0.12.0-1.alpha Linux: nRF_TTM-linux-x64_v0.12.0-1.alpha.tar.gz Extract the package. Run the nRF Thread Topology Monitor executable file nRF_TTM . Flashing the OpenThread CLI nRF Thread Topology Monitor requires [OpenThread CLI] firmware running on your board. Follow these steps to flash the OpenThread CLI pre-built firmware. Connect the nRF52840-MDK board to your PC using the USB-C cable. Open a file explorer. Confirm that the board has appeared as a removable drive named DAPLINK . This allows you to program the nRF52840 chip. Drag and drop the pre-built firmware into DAPLINK . The OpenThread CLI pre-built firmware is located in grove-mesh-kit/firmware/openthread/cli . Tip You can also program the board using pyOCD . Just follow this tutorial to set up the pyOCD tool. Viewing network topology The following steps will show you how to set up the nRF Thread Topology Monitor: Connect the board to your PC using the USB-C cable. In the navigation bar, click Select serial port . Click the Show all button in the dropdown menu and select the serial port. Click Start scan to attach the nRF SoC to the Thread network and to start polling nodes to get information on the current topology. Try to attach other Thread devices to the network. The nRF Thread Topology Monitor will visualize them as shown in the figure below. Tip During the device configuration, you can specify the parameters of the Thread Network: Radio channel , Network PAN ID , Network Master Key . Reference nRF Thread Topology Monitor Product Page nRF Thread Topology Monitor Documentation Create an Issue Interested in contributing to this project? Want to report a bug? Feel free to click here: Create an Issue","title":"Thread Topology Monitor"},{"location":"openthread-mesh/thread-topology-monitor/#thread-topology-monitor","text":"This section describes how to set up the nRF Thread Topology Monitor to visualize the current network topology.","title":"Thread Topology Monitor"},{"location":"openthread-mesh/thread-topology-monitor/#introduction","text":"nRF Thread Topology Monitor is a cross-platform tool that enables developers to visualize Thread mesh network topology in real time. The tool is supported on Windows and Linux with separate downloads for each platform. It requires a serial connection to an nRF52840 board with Nordic\u2019s Thread solution. nRF Thread Topology Monitor uses diagnostic mechanisms of the Thread protocol to retrieve information about routing tables of each Thread Router currently attached to the network. The tool also allows to identify a particular device in the network using LEDs by interacting with the Thread BSP solution. You may assign a custom label to a Thread node and store it in persistent memory on the PC side, which helps to track topology changes.","title":"Introduction"},{"location":"openthread-mesh/thread-topology-monitor/#installation","text":"Navigate to nRF Thread Topology Monitor page and download one of the following packages: Windows: nRF_TTM-win32-x64_v0.12.0-1.alpha Linux: nRF_TTM-linux-x64_v0.12.0-1.alpha.tar.gz Extract the package. Run the nRF Thread Topology Monitor executable file nRF_TTM .","title":"Installation"},{"location":"openthread-mesh/thread-topology-monitor/#flashing-the-openthread-cli","text":"nRF Thread Topology Monitor requires [OpenThread CLI] firmware running on your board. Follow these steps to flash the OpenThread CLI pre-built firmware. Connect the nRF52840-MDK board to your PC using the USB-C cable. Open a file explorer. Confirm that the board has appeared as a removable drive named DAPLINK . This allows you to program the nRF52840 chip. Drag and drop the pre-built firmware into DAPLINK . The OpenThread CLI pre-built firmware is located in grove-mesh-kit/firmware/openthread/cli . Tip You can also program the board using pyOCD . Just follow this tutorial to set up the pyOCD tool.","title":"Flashing the OpenThread CLI"},{"location":"openthread-mesh/thread-topology-monitor/#viewing-network-topology","text":"The following steps will show you how to set up the nRF Thread Topology Monitor: Connect the board to your PC using the USB-C cable. In the navigation bar, click Select serial port . Click the Show all button in the dropdown menu and select the serial port. Click Start scan to attach the nRF SoC to the Thread network and to start polling nodes to get information on the current topology. Try to attach other Thread devices to the network. The nRF Thread Topology Monitor will visualize them as shown in the figure below. Tip During the device configuration, you can specify the parameters of the Thread Network: Radio channel , Network PAN ID , Network Master Key .","title":"Viewing network topology"},{"location":"openthread-mesh/thread-topology-monitor/#reference","text":"nRF Thread Topology Monitor Product Page nRF Thread Topology Monitor Documentation","title":"Reference"},{"location":"openthread-mesh/thread-topology-monitor/#create-an-issue","text":"Interested in contributing to this project? Want to report a bug? Feel free to click here: Create an Issue","title":"Create an Issue"}]}